// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auctionmark.proto

#include "auctionmark.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace auctionmark {
PROTOBUF_CONSTEXPR RegionRow::RegionRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.r_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.r_id_)*/0u} {}
struct RegionRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegionRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegionRowDefaultTypeInternal() {}
  union {
    RegionRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegionRowDefaultTypeInternal _RegionRow_default_instance_;
PROTOBUF_CONSTEXPR GlobalAttributeGroupRow::GlobalAttributeGroupRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gag_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gag_id_)*/0u
  , /*decltype(_impl_.gag_c_id_)*/0u} {}
struct GlobalAttributeGroupRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlobalAttributeGroupRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlobalAttributeGroupRowDefaultTypeInternal() {}
  union {
    GlobalAttributeGroupRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlobalAttributeGroupRowDefaultTypeInternal _GlobalAttributeGroupRow_default_instance_;
PROTOBUF_CONSTEXPR GlobalAttributeValueRow::GlobalAttributeValueRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gav_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gav_id_)*/0u
  , /*decltype(_impl_.gav_gag_id_)*/0u} {}
struct GlobalAttributeValueRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlobalAttributeValueRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlobalAttributeValueRowDefaultTypeInternal() {}
  union {
    GlobalAttributeValueRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlobalAttributeValueRowDefaultTypeInternal _GlobalAttributeValueRow_default_instance_;
PROTOBUF_CONSTEXPR CategoryRow::CategoryRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.c_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.c_id_)*/0u
  , /*decltype(_impl_.c_parent_id_)*/0u} {}
struct CategoryRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CategoryRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CategoryRowDefaultTypeInternal() {}
  union {
    CategoryRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CategoryRowDefaultTypeInternal _CategoryRow_default_instance_;
PROTOBUF_CONSTEXPR UserRow::UserRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.u_sattr0_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr3_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr4_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr5_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr6_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_sattr7_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u_id_)*/0u
  , /*decltype(_impl_.u_rating_)*/0u
  , /*decltype(_impl_.u_balance_)*/0
  , /*decltype(_impl_.u_created_)*/0u
  , /*decltype(_impl_.u_r_id_)*/0u} {}
struct UserRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserRowDefaultTypeInternal() {}
  union {
    UserRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserRowDefaultTypeInternal _UserRow_default_instance_;
PROTOBUF_CONSTEXPR UserAttributeRow::UserAttributeRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ua_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ua_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ua_id_)*/0u
  , /*decltype(_impl_.ua_u_id_)*/0u
  , /*decltype(_impl_.u_created_)*/0u} {}
struct UserAttributeRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserAttributeRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserAttributeRowDefaultTypeInternal() {}
  union {
    UserAttributeRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserAttributeRowDefaultTypeInternal _UserAttributeRow_default_instance_;
PROTOBUF_CONSTEXPR ItemRow::ItemRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.i_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.i_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.i_user_attributes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.i_id_)*/0u
  , /*decltype(_impl_.i_u_id_)*/0u
  , /*decltype(_impl_.i_c_id_)*/0u
  , /*decltype(_impl_.i_num_bids_)*/0u
  , /*decltype(_impl_.i_initial_price_)*/0
  , /*decltype(_impl_.i_current_price_)*/0
  , /*decltype(_impl_.i_num_images_)*/0u
  , /*decltype(_impl_.i_num_global_attrs_)*/0u
  , /*decltype(_impl_.i_start_date_)*/0u
  , /*decltype(_impl_.i_end_date_)*/0u
  , /*decltype(_impl_.i_status_)*/0u} {}
struct ItemRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemRowDefaultTypeInternal() {}
  union {
    ItemRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemRowDefaultTypeInternal _ItemRow_default_instance_;
PROTOBUF_CONSTEXPR ItemImageRow::ItemImageRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ii_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ii_id_)*/0u
  , /*decltype(_impl_.ii_i_id_)*/0u
  , /*decltype(_impl_.ii_u_id_)*/0u} {}
struct ItemImageRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemImageRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemImageRowDefaultTypeInternal() {}
  union {
    ItemImageRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemImageRowDefaultTypeInternal _ItemImageRow_default_instance_;
PROTOBUF_CONSTEXPR ItemCommentRow::ItemCommentRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ic_question_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ic_response_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ic_id_)*/0u
  , /*decltype(_impl_.ic_i_id_)*/0u
  , /*decltype(_impl_.ic_u_id_)*/0u
  , /*decltype(_impl_.ic_buyer_id_)*/0u
  , /*decltype(_impl_.ic_date_)*/0u} {}
struct ItemCommentRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemCommentRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemCommentRowDefaultTypeInternal() {}
  union {
    ItemCommentRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemCommentRowDefaultTypeInternal _ItemCommentRow_default_instance_;
PROTOBUF_CONSTEXPR ItemFeedbackRow::ItemFeedbackRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.if_comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.if_id_)*/0u
  , /*decltype(_impl_.if_i_id_)*/0u
  , /*decltype(_impl_.if_u_id_)*/0u
  , /*decltype(_impl_.if_buyer_id_)*/0u
  , /*decltype(_impl_.if_rating_)*/0u
  , /*decltype(_impl_.if_date_)*/0u} {}
struct ItemFeedbackRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemFeedbackRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemFeedbackRowDefaultTypeInternal() {}
  union {
    ItemFeedbackRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemFeedbackRowDefaultTypeInternal _ItemFeedbackRow_default_instance_;
PROTOBUF_CONSTEXPR ItemBidRow::ItemBidRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ib_id_)*/0u
  , /*decltype(_impl_.ib_i_id_)*/0u
  , /*decltype(_impl_.ib_u_id_)*/0u
  , /*decltype(_impl_.ib_buyer_id_)*/0u
  , /*decltype(_impl_.ib_bid_)*/0
  , /*decltype(_impl_.ib_max_bid_)*/0
  , /*decltype(_impl_.ib_created_)*/0u
  , /*decltype(_impl_.ib_updated_)*/0u} {}
struct ItemBidRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemBidRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemBidRowDefaultTypeInternal() {}
  union {
    ItemBidRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemBidRowDefaultTypeInternal _ItemBidRow_default_instance_;
PROTOBUF_CONSTEXPR ItemMaxBidRow::ItemMaxBidRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.imb_i_id_)*/0u
  , /*decltype(_impl_.imb_u_id_)*/0u
  , /*decltype(_impl_.imb_ib_id_)*/0u
  , /*decltype(_impl_.imb_ib_i_id_)*/0u
  , /*decltype(_impl_.imb_ib_u_id_)*/0u
  , /*decltype(_impl_.imb_created_)*/0u
  , /*decltype(_impl_.imb_updated_)*/0u} {}
struct ItemMaxBidRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemMaxBidRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemMaxBidRowDefaultTypeInternal() {}
  union {
    ItemMaxBidRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemMaxBidRowDefaultTypeInternal _ItemMaxBidRow_default_instance_;
PROTOBUF_CONSTEXPR ItemPurchaseRow::ItemPurchaseRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_id_)*/0u
  , /*decltype(_impl_.ip_ib_id_)*/0u
  , /*decltype(_impl_.ip_i_id_)*/0u
  , /*decltype(_impl_.ip_u_id_)*/0u
  , /*decltype(_impl_.ip_date_)*/0u} {}
struct ItemPurchaseRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemPurchaseRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemPurchaseRowDefaultTypeInternal() {}
  union {
    ItemPurchaseRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemPurchaseRowDefaultTypeInternal _ItemPurchaseRow_default_instance_;
PROTOBUF_CONSTEXPR UserItemRow::UserItemRow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ui_u_id_)*/0u
  , /*decltype(_impl_.ui_i_id_)*/0u
  , /*decltype(_impl_.ui_seller_id_)*/0u
  , /*decltype(_impl_.ui_created_)*/0u} {}
struct UserItemRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserItemRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserItemRowDefaultTypeInternal() {}
  union {
    UserItemRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserItemRowDefaultTypeInternal _UserItemRow_default_instance_;
}  // namespace auctionmark
static ::_pb::Metadata file_level_metadata_auctionmark_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_auctionmark_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_auctionmark_2eproto = nullptr;

const uint32_t TableStruct_auctionmark_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::auctionmark::RegionRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::RegionRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::RegionRow, _impl_.r_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::RegionRow, _impl_.r_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeGroupRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeGroupRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeGroupRow, _impl_.gag_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeGroupRow, _impl_.gag_c_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeGroupRow, _impl_.gag_name_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeValueRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeValueRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeValueRow, _impl_.gav_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeValueRow, _impl_.gav_gag_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::GlobalAttributeValueRow, _impl_.gav_name_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::auctionmark::CategoryRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::CategoryRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::CategoryRow, _impl_.c_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::CategoryRow, _impl_.c_name_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::CategoryRow, _impl_.c_parent_id_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_rating_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_balance_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_created_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_r_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr0_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr1_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr2_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr3_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr4_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr5_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr6_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserRow, _impl_.u_sattr7_),
  8,
  9,
  10,
  11,
  12,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_.ua_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_.ua_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_.ua_name_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_.ua_value_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserAttributeRow, _impl_.u_created_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_c_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_name_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_description_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_user_attributes_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_initial_price_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_current_price_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_num_bids_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_num_images_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_num_global_attrs_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_start_date_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_end_date_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemRow, _impl_.i_status_),
  3,
  4,
  5,
  0,
  1,
  2,
  7,
  8,
  6,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _impl_.ii_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _impl_.ii_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _impl_.ii_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemImageRow, _impl_.ii_path_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_buyer_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_date_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_question_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemCommentRow, _impl_.ic_response_),
  2,
  3,
  4,
  5,
  6,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_buyer_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_rating_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_date_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemFeedbackRow, _impl_.if_comment_),
  1,
  2,
  3,
  4,
  5,
  6,
  0,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_buyer_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_bid_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_max_bid_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_created_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemBidRow, _impl_.ib_updated_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_ib_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_ib_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_ib_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_created_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemMaxBidRow, _impl_.imb_updated_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_.ip_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_.ip_ib_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_.ip_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_.ip_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::ItemPurchaseRow, _impl_.ip_date_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _impl_.ui_u_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _impl_.ui_i_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _impl_.ui_seller_id_),
  PROTOBUF_FIELD_OFFSET(::auctionmark::UserItemRow, _impl_.ui_created_),
  0,
  1,
  2,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::auctionmark::RegionRow)},
  { 10, 19, -1, sizeof(::auctionmark::GlobalAttributeGroupRow)},
  { 22, 31, -1, sizeof(::auctionmark::GlobalAttributeValueRow)},
  { 34, 43, -1, sizeof(::auctionmark::CategoryRow)},
  { 46, 65, -1, sizeof(::auctionmark::UserRow)},
  { 78, 89, -1, sizeof(::auctionmark::UserAttributeRow)},
  { 94, 114, -1, sizeof(::auctionmark::ItemRow)},
  { 128, 138, -1, sizeof(::auctionmark::ItemImageRow)},
  { 142, 155, -1, sizeof(::auctionmark::ItemCommentRow)},
  { 162, 175, -1, sizeof(::auctionmark::ItemFeedbackRow)},
  { 182, 196, -1, sizeof(::auctionmark::ItemBidRow)},
  { 204, 217, -1, sizeof(::auctionmark::ItemMaxBidRow)},
  { 224, 235, -1, sizeof(::auctionmark::ItemPurchaseRow)},
  { 240, 250, -1, sizeof(::auctionmark::UserItemRow)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::auctionmark::_RegionRow_default_instance_._instance,
  &::auctionmark::_GlobalAttributeGroupRow_default_instance_._instance,
  &::auctionmark::_GlobalAttributeValueRow_default_instance_._instance,
  &::auctionmark::_CategoryRow_default_instance_._instance,
  &::auctionmark::_UserRow_default_instance_._instance,
  &::auctionmark::_UserAttributeRow_default_instance_._instance,
  &::auctionmark::_ItemRow_default_instance_._instance,
  &::auctionmark::_ItemImageRow_default_instance_._instance,
  &::auctionmark::_ItemCommentRow_default_instance_._instance,
  &::auctionmark::_ItemFeedbackRow_default_instance_._instance,
  &::auctionmark::_ItemBidRow_default_instance_._instance,
  &::auctionmark::_ItemMaxBidRow_default_instance_._instance,
  &::auctionmark::_ItemPurchaseRow_default_instance_._instance,
  &::auctionmark::_UserItemRow_default_instance_._instance,
};

const char descriptor_table_protodef_auctionmark_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021auctionmark.proto\022\013auctionmark\")\n\tRegi"
  "onRow\022\014\n\004r_id\030\001 \002(\r\022\016\n\006r_name\030\002 \002(\t\"M\n\027G"
  "lobalAttributeGroupRow\022\016\n\006gag_id\030\001 \002(\r\022\020"
  "\n\010gag_c_id\030\002 \002(\r\022\020\n\010gag_name\030\003 \002(\t\"O\n\027Gl"
  "obalAttributeValueRow\022\016\n\006gav_id\030\001 \002(\r\022\022\n"
  "\ngav_gag_id\030\002 \002(\r\022\020\n\010gav_name\030\003 \002(\t\"@\n\013C"
  "ategoryRow\022\014\n\004c_id\030\001 \002(\r\022\016\n\006c_name\030\002 \002(\t"
  "\022\023\n\013c_parent_id\030\003 \002(\r\"\357\001\n\007UserRow\022\014\n\004u_i"
  "d\030\001 \002(\r\022\020\n\010u_rating\030\002 \002(\r\022\021\n\tu_balance\030\003"
  " \002(\001\022\021\n\tu_created\030\004 \002(\r\022\016\n\006u_r_id\030\005 \002(\r\022"
  "\020\n\010u_sattr0\030\006 \002(\t\022\020\n\010u_sattr1\030\007 \002(\t\022\020\n\010u"
  "_sattr2\030\010 \002(\t\022\020\n\010u_sattr3\030\t \002(\t\022\020\n\010u_sat"
  "tr4\030\n \002(\t\022\020\n\010u_sattr5\030\013 \002(\t\022\020\n\010u_sattr6\030"
  "\014 \002(\t\022\020\n\010u_sattr7\030\r \002(\t\"h\n\020UserAttribute"
  "Row\022\r\n\005ua_id\030\001 \002(\r\022\017\n\007ua_u_id\030\002 \002(\r\022\017\n\007u"
  "a_name\030\003 \002(\t\022\020\n\010ua_value\030\004 \002(\t\022\021\n\tu_crea"
  "ted\030\005 \002(\r\"\255\002\n\007ItemRow\022\014\n\004i_id\030\001 \002(\r\022\016\n\006i"
  "_u_id\030\002 \002(\r\022\016\n\006i_c_id\030\003 \002(\r\022\016\n\006i_name\030\004 "
  "\002(\t\022\025\n\ri_description\030\005 \002(\t\022\031\n\021i_user_att"
  "ributes\030\006 \002(\t\022\027\n\017i_initial_price\030\007 \002(\001\022\027"
  "\n\017i_current_price\030\010 \002(\001\022\022\n\ni_num_bids\030\t "
  "\002(\r\022\024\n\014i_num_images\030\n \002(\r\022\032\n\022i_num_globa"
  "l_attrs\030\013 \002(\r\022\024\n\014i_start_date\030\014 \002(\r\022\022\n\ni"
  "_end_date\030\r \002(\r\022\020\n\010i_status\030\016 \002(\r\"P\n\014Ite"
  "mImageRow\022\r\n\005ii_id\030\001 \002(\r\022\017\n\007ii_i_id\030\002 \002("
  "\r\022\017\n\007ii_u_id\030\003 \002(\r\022\017\n\007ii_path\030\004 \002(\t\"\221\001\n\016"
  "ItemCommentRow\022\r\n\005ic_id\030\001 \002(\r\022\017\n\007ic_i_id"
  "\030\002 \002(\r\022\017\n\007ic_u_id\030\003 \002(\r\022\023\n\013ic_buyer_id\030\004"
  " \002(\r\022\017\n\007ic_date\030\005 \002(\r\022\023\n\013ic_question\030\006 \002"
  "(\t\022\023\n\013ic_response\030\007 \002(\t\"\217\001\n\017ItemFeedback"
  "Row\022\r\n\005if_id\030\001 \002(\r\022\017\n\007if_i_id\030\002 \002(\r\022\017\n\007i"
  "f_u_id\030\003 \002(\r\022\023\n\013if_buyer_id\030\004 \002(\r\022\021\n\tif_"
  "rating\030\005 \002(\r\022\017\n\007if_date\030\006 \002(\r\022\022\n\nif_comm"
  "ent\030\007 \002(\t\"\236\001\n\nItemBidRow\022\r\n\005ib_id\030\001 \002(\r\022"
  "\017\n\007ib_i_id\030\002 \002(\r\022\017\n\007ib_u_id\030\003 \002(\r\022\023\n\013ib_"
  "buyer_id\030\004 \002(\r\022\016\n\006ib_bid\030\005 \002(\001\022\022\n\nib_max"
  "_bid\030\006 \002(\001\022\022\n\nib_created\030\007 \002(\r\022\022\n\nib_upd"
  "ated\030\010 \002(\r\"\232\001\n\rItemMaxBidRow\022\020\n\010imb_i_id"
  "\030\001 \002(\r\022\020\n\010imb_u_id\030\002 \002(\r\022\021\n\timb_ib_id\030\003 "
  "\002(\r\022\023\n\013imb_ib_i_id\030\004 \002(\r\022\023\n\013imb_ib_u_id\030"
  "\005 \002(\r\022\023\n\013imb_created\030\006 \002(\r\022\023\n\013imb_update"
  "d\030\007 \002(\r\"e\n\017ItemPurchaseRow\022\r\n\005ip_id\030\001 \002("
  "\r\022\020\n\010ip_ib_id\030\002 \002(\r\022\017\n\007ip_i_id\030\003 \002(\r\022\017\n\007"
  "ip_u_id\030\004 \002(\r\022\017\n\007ip_date\030\005 \002(\r\"Y\n\013UserIt"
  "emRow\022\017\n\007ui_u_id\030\001 \002(\r\022\017\n\007ui_i_id\030\002 \002(\r\022"
  "\024\n\014ui_seller_id\030\003 \002(\r\022\022\n\nui_created\030\004 \002("
  "\r*\235\002\n\006Tables\022\n\n\006REGION\020\000\022\032\n\026GLOBAL_ATTRI"
  "BUTE_GROUP\020\001\022\032\n\026GLOBAL_ATTRIBUTE_VALUE\020\002"
  "\022\014\n\010CATEGORY\020\003\022\010\n\004USER\020\004\022\022\n\016USER_ATTRIBU"
  "TE\020\005\022\016\n\nUSER_WATCH\020\006\022\010\n\004ITEM\020\007\022\014\n\010ITEM_B"
  "ID\020\010\022\021\n\rITEM_FEEDBACK\020\t\022\022\n\016ITEM_ATTRIBUT"
  "E\020\n\022\016\n\nITEM_IMAGE\020\013\022\020\n\014ITEM_COMMENT\020\014\022\020\n"
  "\014ITEM_MAX_BID\020\r\022\021\n\rITEM_PURCHASE\020\016\022\r\n\tUS"
  "ER_ITEM\020\017"
  ;
static ::_pbi::once_flag descriptor_table_auctionmark_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_auctionmark_2eproto = {
    false, false, 2129, descriptor_table_protodef_auctionmark_2eproto,
    "auctionmark.proto",
    &descriptor_table_auctionmark_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_auctionmark_2eproto::offsets,
    file_level_metadata_auctionmark_2eproto, file_level_enum_descriptors_auctionmark_2eproto,
    file_level_service_descriptors_auctionmark_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_auctionmark_2eproto_getter() {
  return &descriptor_table_auctionmark_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_auctionmark_2eproto(&descriptor_table_auctionmark_2eproto);
namespace auctionmark {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tables_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_auctionmark_2eproto);
  return file_level_enum_descriptors_auctionmark_2eproto[0];
}
bool Tables_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class RegionRow::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionRow>()._impl_._has_bits_);
  static void set_has_r_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_r_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RegionRow::RegionRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.RegionRow)
}
RegionRow::RegionRow(const RegionRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RegionRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.r_name_){}
    , decltype(_impl_.r_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.r_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.r_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_r_name()) {
    _this->_impl_.r_name_.Set(from._internal_r_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.r_id_ = from._impl_.r_id_;
  // @@protoc_insertion_point(copy_constructor:auctionmark.RegionRow)
}

inline void RegionRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.r_name_){}
    , decltype(_impl_.r_id_){0u}
  };
  _impl_.r_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.r_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegionRow::~RegionRow() {
  // @@protoc_insertion_point(destructor:auctionmark.RegionRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegionRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.r_name_.Destroy();
}

void RegionRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegionRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.RegionRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.r_name_.ClearNonDefaultToEmpty();
  }
  _impl_.r_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 r_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_r_id(&has_bits);
          _impl_.r_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string r_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_r_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.RegionRow.r_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegionRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.RegionRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 r_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_r_id(), target);
  }

  // required string r_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_r_name().data(), static_cast<int>(this->_internal_r_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.RegionRow.r_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_r_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.RegionRow)
  return target;
}

size_t RegionRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.RegionRow)
  size_t total_size = 0;

  if (_internal_has_r_name()) {
    // required string r_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_r_name());
  }

  if (_internal_has_r_id()) {
    // required uint32 r_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_r_id());
  }

  return total_size;
}
size_t RegionRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.RegionRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string r_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_r_name());

    // required uint32 r_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_r_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RegionRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionRow::GetClassData() const { return &_class_data_; }


void RegionRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RegionRow*>(&to_msg);
  auto& from = static_cast<const RegionRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.RegionRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_r_name(from._internal_r_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.r_id_ = from._impl_.r_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionRow::CopyFrom(const RegionRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.RegionRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RegionRow::InternalSwap(RegionRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.r_name_, lhs_arena,
      &other->_impl_.r_name_, rhs_arena
  );
  swap(_impl_.r_id_, other->_impl_.r_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[0]);
}

// ===================================================================

class GlobalAttributeGroupRow::_Internal {
 public:
  using HasBits = decltype(std::declval<GlobalAttributeGroupRow>()._impl_._has_bits_);
  static void set_has_gag_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gag_c_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gag_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GlobalAttributeGroupRow::GlobalAttributeGroupRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.GlobalAttributeGroupRow)
}
GlobalAttributeGroupRow::GlobalAttributeGroupRow(const GlobalAttributeGroupRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GlobalAttributeGroupRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gag_name_){}
    , decltype(_impl_.gag_id_){}
    , decltype(_impl_.gag_c_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gag_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gag_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gag_name()) {
    _this->_impl_.gag_name_.Set(from._internal_gag_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gag_id_, &from._impl_.gag_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gag_c_id_) -
    reinterpret_cast<char*>(&_impl_.gag_id_)) + sizeof(_impl_.gag_c_id_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.GlobalAttributeGroupRow)
}

inline void GlobalAttributeGroupRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gag_name_){}
    , decltype(_impl_.gag_id_){0u}
    , decltype(_impl_.gag_c_id_){0u}
  };
  _impl_.gag_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gag_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GlobalAttributeGroupRow::~GlobalAttributeGroupRow() {
  // @@protoc_insertion_point(destructor:auctionmark.GlobalAttributeGroupRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlobalAttributeGroupRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gag_name_.Destroy();
}

void GlobalAttributeGroupRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlobalAttributeGroupRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.GlobalAttributeGroupRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.gag_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.gag_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gag_c_id_) -
        reinterpret_cast<char*>(&_impl_.gag_id_)) + sizeof(_impl_.gag_c_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlobalAttributeGroupRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gag_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gag_id(&has_bits);
          _impl_.gag_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 gag_c_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gag_c_id(&has_bits);
          _impl_.gag_c_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string gag_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gag_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.GlobalAttributeGroupRow.gag_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlobalAttributeGroupRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.GlobalAttributeGroupRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 gag_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gag_id(), target);
  }

  // required uint32 gag_c_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gag_c_id(), target);
  }

  // required string gag_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gag_name().data(), static_cast<int>(this->_internal_gag_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.GlobalAttributeGroupRow.gag_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gag_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.GlobalAttributeGroupRow)
  return target;
}

size_t GlobalAttributeGroupRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.GlobalAttributeGroupRow)
  size_t total_size = 0;

  if (_internal_has_gag_name()) {
    // required string gag_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gag_name());
  }

  if (_internal_has_gag_id()) {
    // required uint32 gag_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gag_id());
  }

  if (_internal_has_gag_c_id()) {
    // required uint32 gag_c_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gag_c_id());
  }

  return total_size;
}
size_t GlobalAttributeGroupRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.GlobalAttributeGroupRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string gag_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gag_name());

    // required uint32 gag_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gag_id());

    // required uint32 gag_c_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gag_c_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlobalAttributeGroupRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GlobalAttributeGroupRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlobalAttributeGroupRow::GetClassData() const { return &_class_data_; }


void GlobalAttributeGroupRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GlobalAttributeGroupRow*>(&to_msg);
  auto& from = static_cast<const GlobalAttributeGroupRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.GlobalAttributeGroupRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gag_name(from._internal_gag_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gag_id_ = from._impl_.gag_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gag_c_id_ = from._impl_.gag_c_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlobalAttributeGroupRow::CopyFrom(const GlobalAttributeGroupRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.GlobalAttributeGroupRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalAttributeGroupRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GlobalAttributeGroupRow::InternalSwap(GlobalAttributeGroupRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gag_name_, lhs_arena,
      &other->_impl_.gag_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlobalAttributeGroupRow, _impl_.gag_c_id_)
      + sizeof(GlobalAttributeGroupRow::_impl_.gag_c_id_)
      - PROTOBUF_FIELD_OFFSET(GlobalAttributeGroupRow, _impl_.gag_id_)>(
          reinterpret_cast<char*>(&_impl_.gag_id_),
          reinterpret_cast<char*>(&other->_impl_.gag_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GlobalAttributeGroupRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[1]);
}

// ===================================================================

class GlobalAttributeValueRow::_Internal {
 public:
  using HasBits = decltype(std::declval<GlobalAttributeValueRow>()._impl_._has_bits_);
  static void set_has_gav_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gav_gag_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gav_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GlobalAttributeValueRow::GlobalAttributeValueRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.GlobalAttributeValueRow)
}
GlobalAttributeValueRow::GlobalAttributeValueRow(const GlobalAttributeValueRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GlobalAttributeValueRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gav_name_){}
    , decltype(_impl_.gav_id_){}
    , decltype(_impl_.gav_gag_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gav_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gav_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gav_name()) {
    _this->_impl_.gav_name_.Set(from._internal_gav_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gav_id_, &from._impl_.gav_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gav_gag_id_) -
    reinterpret_cast<char*>(&_impl_.gav_id_)) + sizeof(_impl_.gav_gag_id_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.GlobalAttributeValueRow)
}

inline void GlobalAttributeValueRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gav_name_){}
    , decltype(_impl_.gav_id_){0u}
    , decltype(_impl_.gav_gag_id_){0u}
  };
  _impl_.gav_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gav_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GlobalAttributeValueRow::~GlobalAttributeValueRow() {
  // @@protoc_insertion_point(destructor:auctionmark.GlobalAttributeValueRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlobalAttributeValueRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gav_name_.Destroy();
}

void GlobalAttributeValueRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlobalAttributeValueRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.GlobalAttributeValueRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.gav_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.gav_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gav_gag_id_) -
        reinterpret_cast<char*>(&_impl_.gav_id_)) + sizeof(_impl_.gav_gag_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlobalAttributeValueRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 gav_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gav_id(&has_bits);
          _impl_.gav_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 gav_gag_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gav_gag_id(&has_bits);
          _impl_.gav_gag_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string gav_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gav_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.GlobalAttributeValueRow.gav_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlobalAttributeValueRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.GlobalAttributeValueRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 gav_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gav_id(), target);
  }

  // required uint32 gav_gag_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gav_gag_id(), target);
  }

  // required string gav_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gav_name().data(), static_cast<int>(this->_internal_gav_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.GlobalAttributeValueRow.gav_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gav_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.GlobalAttributeValueRow)
  return target;
}

size_t GlobalAttributeValueRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.GlobalAttributeValueRow)
  size_t total_size = 0;

  if (_internal_has_gav_name()) {
    // required string gav_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gav_name());
  }

  if (_internal_has_gav_id()) {
    // required uint32 gav_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gav_id());
  }

  if (_internal_has_gav_gag_id()) {
    // required uint32 gav_gag_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gav_gag_id());
  }

  return total_size;
}
size_t GlobalAttributeValueRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.GlobalAttributeValueRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string gav_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gav_name());

    // required uint32 gav_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gav_id());

    // required uint32 gav_gag_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gav_gag_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlobalAttributeValueRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GlobalAttributeValueRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlobalAttributeValueRow::GetClassData() const { return &_class_data_; }


void GlobalAttributeValueRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GlobalAttributeValueRow*>(&to_msg);
  auto& from = static_cast<const GlobalAttributeValueRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.GlobalAttributeValueRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gav_name(from._internal_gav_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gav_id_ = from._impl_.gav_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gav_gag_id_ = from._impl_.gav_gag_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlobalAttributeValueRow::CopyFrom(const GlobalAttributeValueRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.GlobalAttributeValueRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalAttributeValueRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GlobalAttributeValueRow::InternalSwap(GlobalAttributeValueRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gav_name_, lhs_arena,
      &other->_impl_.gav_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlobalAttributeValueRow, _impl_.gav_gag_id_)
      + sizeof(GlobalAttributeValueRow::_impl_.gav_gag_id_)
      - PROTOBUF_FIELD_OFFSET(GlobalAttributeValueRow, _impl_.gav_id_)>(
          reinterpret_cast<char*>(&_impl_.gav_id_),
          reinterpret_cast<char*>(&other->_impl_.gav_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GlobalAttributeValueRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[2]);
}

// ===================================================================

class CategoryRow::_Internal {
 public:
  using HasBits = decltype(std::declval<CategoryRow>()._impl_._has_bits_);
  static void set_has_c_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_c_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_c_parent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CategoryRow::CategoryRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.CategoryRow)
}
CategoryRow::CategoryRow(const CategoryRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CategoryRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.c_name_){}
    , decltype(_impl_.c_id_){}
    , decltype(_impl_.c_parent_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.c_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.c_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_c_name()) {
    _this->_impl_.c_name_.Set(from._internal_c_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.c_id_, &from._impl_.c_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.c_parent_id_) -
    reinterpret_cast<char*>(&_impl_.c_id_)) + sizeof(_impl_.c_parent_id_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.CategoryRow)
}

inline void CategoryRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.c_name_){}
    , decltype(_impl_.c_id_){0u}
    , decltype(_impl_.c_parent_id_){0u}
  };
  _impl_.c_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.c_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CategoryRow::~CategoryRow() {
  // @@protoc_insertion_point(destructor:auctionmark.CategoryRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CategoryRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.c_name_.Destroy();
}

void CategoryRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CategoryRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.CategoryRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.c_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.c_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.c_parent_id_) -
        reinterpret_cast<char*>(&_impl_.c_id_)) + sizeof(_impl_.c_parent_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CategoryRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 c_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_c_id(&has_bits);
          _impl_.c_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string c_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_c_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.CategoryRow.c_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 c_parent_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_c_parent_id(&has_bits);
          _impl_.c_parent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CategoryRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.CategoryRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 c_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_c_id(), target);
  }

  // required string c_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_c_name().data(), static_cast<int>(this->_internal_c_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.CategoryRow.c_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_c_name(), target);
  }

  // required uint32 c_parent_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_c_parent_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.CategoryRow)
  return target;
}

size_t CategoryRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.CategoryRow)
  size_t total_size = 0;

  if (_internal_has_c_name()) {
    // required string c_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_c_name());
  }

  if (_internal_has_c_id()) {
    // required uint32 c_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_c_id());
  }

  if (_internal_has_c_parent_id()) {
    // required uint32 c_parent_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_c_parent_id());
  }

  return total_size;
}
size_t CategoryRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.CategoryRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string c_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_c_name());

    // required uint32 c_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_c_id());

    // required uint32 c_parent_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_c_parent_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CategoryRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CategoryRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CategoryRow::GetClassData() const { return &_class_data_; }


void CategoryRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CategoryRow*>(&to_msg);
  auto& from = static_cast<const CategoryRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.CategoryRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_c_name(from._internal_c_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.c_id_ = from._impl_.c_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.c_parent_id_ = from._impl_.c_parent_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CategoryRow::CopyFrom(const CategoryRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.CategoryRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CategoryRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CategoryRow::InternalSwap(CategoryRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.c_name_, lhs_arena,
      &other->_impl_.c_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CategoryRow, _impl_.c_parent_id_)
      + sizeof(CategoryRow::_impl_.c_parent_id_)
      - PROTOBUF_FIELD_OFFSET(CategoryRow, _impl_.c_id_)>(
          reinterpret_cast<char*>(&_impl_.c_id_),
          reinterpret_cast<char*>(&other->_impl_.c_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CategoryRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[3]);
}

// ===================================================================

class UserRow::_Internal {
 public:
  using HasBits = decltype(std::declval<UserRow>()._impl_._has_bits_);
  static void set_has_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_u_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_u_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_u_created(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_u_r_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_u_sattr0(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_u_sattr1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_u_sattr2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_u_sattr3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_sattr4(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_sattr5(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_sattr6(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_u_sattr7(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00001fff) ^ 0x00001fff) != 0;
  }
};

UserRow::UserRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.UserRow)
}
UserRow::UserRow(const UserRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u_sattr0_){}
    , decltype(_impl_.u_sattr1_){}
    , decltype(_impl_.u_sattr2_){}
    , decltype(_impl_.u_sattr3_){}
    , decltype(_impl_.u_sattr4_){}
    , decltype(_impl_.u_sattr5_){}
    , decltype(_impl_.u_sattr6_){}
    , decltype(_impl_.u_sattr7_){}
    , decltype(_impl_.u_id_){}
    , decltype(_impl_.u_rating_){}
    , decltype(_impl_.u_balance_){}
    , decltype(_impl_.u_created_){}
    , decltype(_impl_.u_r_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.u_sattr0_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr0_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr0()) {
    _this->_impl_.u_sattr0_.Set(from._internal_u_sattr0(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr1()) {
    _this->_impl_.u_sattr1_.Set(from._internal_u_sattr1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr2()) {
    _this->_impl_.u_sattr2_.Set(from._internal_u_sattr2(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr3()) {
    _this->_impl_.u_sattr3_.Set(from._internal_u_sattr3(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr4()) {
    _this->_impl_.u_sattr4_.Set(from._internal_u_sattr4(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr5_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr5_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr5()) {
    _this->_impl_.u_sattr5_.Set(from._internal_u_sattr5(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr6()) {
    _this->_impl_.u_sattr6_.Set(from._internal_u_sattr6(), 
      _this->GetArenaForAllocation());
  }
  _impl_.u_sattr7_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr7_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_u_sattr7()) {
    _this->_impl_.u_sattr7_.Set(from._internal_u_sattr7(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.u_id_, &from._impl_.u_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u_r_id_) -
    reinterpret_cast<char*>(&_impl_.u_id_)) + sizeof(_impl_.u_r_id_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.UserRow)
}

inline void UserRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u_sattr0_){}
    , decltype(_impl_.u_sattr1_){}
    , decltype(_impl_.u_sattr2_){}
    , decltype(_impl_.u_sattr3_){}
    , decltype(_impl_.u_sattr4_){}
    , decltype(_impl_.u_sattr5_){}
    , decltype(_impl_.u_sattr6_){}
    , decltype(_impl_.u_sattr7_){}
    , decltype(_impl_.u_id_){0u}
    , decltype(_impl_.u_rating_){0u}
    , decltype(_impl_.u_balance_){0}
    , decltype(_impl_.u_created_){0u}
    , decltype(_impl_.u_r_id_){0u}
  };
  _impl_.u_sattr0_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr0_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr5_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr5_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.u_sattr7_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.u_sattr7_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserRow::~UserRow() {
  // @@protoc_insertion_point(destructor:auctionmark.UserRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.u_sattr0_.Destroy();
  _impl_.u_sattr1_.Destroy();
  _impl_.u_sattr2_.Destroy();
  _impl_.u_sattr3_.Destroy();
  _impl_.u_sattr4_.Destroy();
  _impl_.u_sattr5_.Destroy();
  _impl_.u_sattr6_.Destroy();
  _impl_.u_sattr7_.Destroy();
}

void UserRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.UserRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.u_sattr0_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.u_sattr1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.u_sattr2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.u_sattr3_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.u_sattr4_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.u_sattr5_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.u_sattr6_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.u_sattr7_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.u_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.u_r_id_) -
        reinterpret_cast<char*>(&_impl_.u_id_)) + sizeof(_impl_.u_r_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 u_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_u_id(&has_bits);
          _impl_.u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 u_rating = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_u_rating(&has_bits);
          _impl_.u_rating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double u_balance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_u_balance(&has_bits);
          _impl_.u_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 u_created = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_u_created(&has_bits);
          _impl_.u_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 u_r_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_u_r_id(&has_bits);
          _impl_.u_r_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr0 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_u_sattr0();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr0");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_u_sattr1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr1");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr2 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_u_sattr2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr2");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr3 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_u_sattr3();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr3");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr4 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_u_sattr4();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr4");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr5 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_u_sattr5();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr5");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr6 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_u_sattr6();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr6");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string u_sattr7 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_u_sattr7();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserRow.u_sattr7");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.UserRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 u_id = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_u_id(), target);
  }

  // required uint32 u_rating = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_u_rating(), target);
  }

  // required double u_balance = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_u_balance(), target);
  }

  // required uint32 u_created = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_u_created(), target);
  }

  // required uint32 u_r_id = 5;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_u_r_id(), target);
  }

  // required string u_sattr0 = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr0().data(), static_cast<int>(this->_internal_u_sattr0().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr0");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_u_sattr0(), target);
  }

  // required string u_sattr1 = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr1().data(), static_cast<int>(this->_internal_u_sattr1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr1");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_u_sattr1(), target);
  }

  // required string u_sattr2 = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr2().data(), static_cast<int>(this->_internal_u_sattr2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr2");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_u_sattr2(), target);
  }

  // required string u_sattr3 = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr3().data(), static_cast<int>(this->_internal_u_sattr3().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr3");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_u_sattr3(), target);
  }

  // required string u_sattr4 = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr4().data(), static_cast<int>(this->_internal_u_sattr4().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr4");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_u_sattr4(), target);
  }

  // required string u_sattr5 = 11;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr5().data(), static_cast<int>(this->_internal_u_sattr5().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr5");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_u_sattr5(), target);
  }

  // required string u_sattr6 = 12;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr6().data(), static_cast<int>(this->_internal_u_sattr6().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr6");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_u_sattr6(), target);
  }

  // required string u_sattr7 = 13;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_u_sattr7().data(), static_cast<int>(this->_internal_u_sattr7().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserRow.u_sattr7");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_u_sattr7(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.UserRow)
  return target;
}

size_t UserRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.UserRow)
  size_t total_size = 0;

  if (_internal_has_u_sattr0()) {
    // required string u_sattr0 = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr0());
  }

  if (_internal_has_u_sattr1()) {
    // required string u_sattr1 = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr1());
  }

  if (_internal_has_u_sattr2()) {
    // required string u_sattr2 = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr2());
  }

  if (_internal_has_u_sattr3()) {
    // required string u_sattr3 = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr3());
  }

  if (_internal_has_u_sattr4()) {
    // required string u_sattr4 = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr4());
  }

  if (_internal_has_u_sattr5()) {
    // required string u_sattr5 = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr5());
  }

  if (_internal_has_u_sattr6()) {
    // required string u_sattr6 = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr6());
  }

  if (_internal_has_u_sattr7()) {
    // required string u_sattr7 = 13;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr7());
  }

  if (_internal_has_u_id()) {
    // required uint32 u_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_id());
  }

  if (_internal_has_u_rating()) {
    // required uint32 u_rating = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_rating());
  }

  if (_internal_has_u_balance()) {
    // required double u_balance = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_u_created()) {
    // required uint32 u_created = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_created());
  }

  if (_internal_has_u_r_id()) {
    // required uint32 u_r_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_r_id());
  }

  return total_size;
}
size_t UserRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.UserRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00001fff) ^ 0x00001fff) == 0) {  // All required fields are present.
    // required string u_sattr0 = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr0());

    // required string u_sattr1 = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr1());

    // required string u_sattr2 = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr2());

    // required string u_sattr3 = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr3());

    // required string u_sattr4 = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr4());

    // required string u_sattr5 = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr5());

    // required string u_sattr6 = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr6());

    // required string u_sattr7 = 13;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_u_sattr7());

    // required uint32 u_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_id());

    // required uint32 u_rating = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_rating());

    // required double u_balance = 3;
    total_size += 1 + 8;

    // required uint32 u_created = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_created());

    // required uint32 u_r_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_r_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserRow::GetClassData() const { return &_class_data_; }


void UserRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserRow*>(&to_msg);
  auto& from = static_cast<const UserRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.UserRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_u_sattr0(from._internal_u_sattr0());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_u_sattr1(from._internal_u_sattr1());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_u_sattr2(from._internal_u_sattr2());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_u_sattr3(from._internal_u_sattr3());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_u_sattr4(from._internal_u_sattr4());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_u_sattr5(from._internal_u_sattr5());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_u_sattr6(from._internal_u_sattr6());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_u_sattr7(from._internal_u_sattr7());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.u_id_ = from._impl_.u_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.u_rating_ = from._impl_.u_rating_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.u_balance_ = from._impl_.u_balance_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.u_created_ = from._impl_.u_created_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.u_r_id_ = from._impl_.u_r_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserRow::CopyFrom(const UserRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.UserRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserRow::InternalSwap(UserRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr0_, lhs_arena,
      &other->_impl_.u_sattr0_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr1_, lhs_arena,
      &other->_impl_.u_sattr1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr2_, lhs_arena,
      &other->_impl_.u_sattr2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr3_, lhs_arena,
      &other->_impl_.u_sattr3_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr4_, lhs_arena,
      &other->_impl_.u_sattr4_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr5_, lhs_arena,
      &other->_impl_.u_sattr5_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr6_, lhs_arena,
      &other->_impl_.u_sattr6_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.u_sattr7_, lhs_arena,
      &other->_impl_.u_sattr7_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserRow, _impl_.u_r_id_)
      + sizeof(UserRow::_impl_.u_r_id_)
      - PROTOBUF_FIELD_OFFSET(UserRow, _impl_.u_id_)>(
          reinterpret_cast<char*>(&_impl_.u_id_),
          reinterpret_cast<char*>(&other->_impl_.u_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[4]);
}

// ===================================================================

class UserAttributeRow::_Internal {
 public:
  using HasBits = decltype(std::declval<UserAttributeRow>()._impl_._has_bits_);
  static void set_has_ua_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ua_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ua_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ua_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_u_created(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

UserAttributeRow::UserAttributeRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.UserAttributeRow)
}
UserAttributeRow::UserAttributeRow(const UserAttributeRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserAttributeRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ua_name_){}
    , decltype(_impl_.ua_value_){}
    , decltype(_impl_.ua_id_){}
    , decltype(_impl_.ua_u_id_){}
    , decltype(_impl_.u_created_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ua_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ua_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ua_name()) {
    _this->_impl_.ua_name_.Set(from._internal_ua_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ua_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ua_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ua_value()) {
    _this->_impl_.ua_value_.Set(from._internal_ua_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ua_id_, &from._impl_.ua_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u_created_) -
    reinterpret_cast<char*>(&_impl_.ua_id_)) + sizeof(_impl_.u_created_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.UserAttributeRow)
}

inline void UserAttributeRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ua_name_){}
    , decltype(_impl_.ua_value_){}
    , decltype(_impl_.ua_id_){0u}
    , decltype(_impl_.ua_u_id_){0u}
    , decltype(_impl_.u_created_){0u}
  };
  _impl_.ua_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ua_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ua_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ua_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserAttributeRow::~UserAttributeRow() {
  // @@protoc_insertion_point(destructor:auctionmark.UserAttributeRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserAttributeRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ua_name_.Destroy();
  _impl_.ua_value_.Destroy();
}

void UserAttributeRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserAttributeRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.UserAttributeRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ua_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ua_value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.ua_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.u_created_) -
        reinterpret_cast<char*>(&_impl_.ua_id_)) + sizeof(_impl_.u_created_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserAttributeRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ua_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ua_id(&has_bits);
          _impl_.ua_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ua_u_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ua_u_id(&has_bits);
          _impl_.ua_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ua_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ua_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserAttributeRow.ua_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ua_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ua_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.UserAttributeRow.ua_value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 u_created = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_u_created(&has_bits);
          _impl_.u_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserAttributeRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.UserAttributeRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ua_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ua_id(), target);
  }

  // required uint32 ua_u_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ua_u_id(), target);
  }

  // required string ua_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ua_name().data(), static_cast<int>(this->_internal_ua_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserAttributeRow.ua_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ua_name(), target);
  }

  // required string ua_value = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ua_value().data(), static_cast<int>(this->_internal_ua_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.UserAttributeRow.ua_value");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ua_value(), target);
  }

  // required uint32 u_created = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_u_created(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.UserAttributeRow)
  return target;
}

size_t UserAttributeRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.UserAttributeRow)
  size_t total_size = 0;

  if (_internal_has_ua_name()) {
    // required string ua_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ua_name());
  }

  if (_internal_has_ua_value()) {
    // required string ua_value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ua_value());
  }

  if (_internal_has_ua_id()) {
    // required uint32 ua_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ua_id());
  }

  if (_internal_has_ua_u_id()) {
    // required uint32 ua_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ua_u_id());
  }

  if (_internal_has_u_created()) {
    // required uint32 u_created = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_created());
  }

  return total_size;
}
size_t UserAttributeRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.UserAttributeRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string ua_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ua_name());

    // required string ua_value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ua_value());

    // required uint32 ua_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ua_id());

    // required uint32 ua_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ua_u_id());

    // required uint32 u_created = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_created());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserAttributeRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserAttributeRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserAttributeRow::GetClassData() const { return &_class_data_; }


void UserAttributeRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserAttributeRow*>(&to_msg);
  auto& from = static_cast<const UserAttributeRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.UserAttributeRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ua_name(from._internal_ua_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ua_value(from._internal_ua_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ua_id_ = from._impl_.ua_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ua_u_id_ = from._impl_.ua_u_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.u_created_ = from._impl_.u_created_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserAttributeRow::CopyFrom(const UserAttributeRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.UserAttributeRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserAttributeRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserAttributeRow::InternalSwap(UserAttributeRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ua_name_, lhs_arena,
      &other->_impl_.ua_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ua_value_, lhs_arena,
      &other->_impl_.ua_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserAttributeRow, _impl_.u_created_)
      + sizeof(UserAttributeRow::_impl_.u_created_)
      - PROTOBUF_FIELD_OFFSET(UserAttributeRow, _impl_.ua_id_)>(
          reinterpret_cast<char*>(&_impl_.ua_id_),
          reinterpret_cast<char*>(&other->_impl_.ua_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserAttributeRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[5]);
}

// ===================================================================

class ItemRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemRow>()._impl_._has_bits_);
  static void set_has_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_i_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_i_c_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_i_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_i_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_user_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_i_initial_price(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_i_current_price(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_i_num_bids(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_i_num_images(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_i_num_global_attrs(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_i_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_i_end_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_i_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00003fff) ^ 0x00003fff) != 0;
  }
};

ItemRow::ItemRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemRow)
}
ItemRow::ItemRow(const ItemRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.i_name_){}
    , decltype(_impl_.i_description_){}
    , decltype(_impl_.i_user_attributes_){}
    , decltype(_impl_.i_id_){}
    , decltype(_impl_.i_u_id_){}
    , decltype(_impl_.i_c_id_){}
    , decltype(_impl_.i_num_bids_){}
    , decltype(_impl_.i_initial_price_){}
    , decltype(_impl_.i_current_price_){}
    , decltype(_impl_.i_num_images_){}
    , decltype(_impl_.i_num_global_attrs_){}
    , decltype(_impl_.i_start_date_){}
    , decltype(_impl_.i_end_date_){}
    , decltype(_impl_.i_status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.i_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_i_name()) {
    _this->_impl_.i_name_.Set(from._internal_i_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.i_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_i_description()) {
    _this->_impl_.i_description_.Set(from._internal_i_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.i_user_attributes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_user_attributes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_i_user_attributes()) {
    _this->_impl_.i_user_attributes_.Set(from._internal_i_user_attributes(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.i_id_, &from._impl_.i_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.i_status_) -
    reinterpret_cast<char*>(&_impl_.i_id_)) + sizeof(_impl_.i_status_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemRow)
}

inline void ItemRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.i_name_){}
    , decltype(_impl_.i_description_){}
    , decltype(_impl_.i_user_attributes_){}
    , decltype(_impl_.i_id_){0u}
    , decltype(_impl_.i_u_id_){0u}
    , decltype(_impl_.i_c_id_){0u}
    , decltype(_impl_.i_num_bids_){0u}
    , decltype(_impl_.i_initial_price_){0}
    , decltype(_impl_.i_current_price_){0}
    , decltype(_impl_.i_num_images_){0u}
    , decltype(_impl_.i_num_global_attrs_){0u}
    , decltype(_impl_.i_start_date_){0u}
    , decltype(_impl_.i_end_date_){0u}
    , decltype(_impl_.i_status_){0u}
  };
  _impl_.i_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.i_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.i_user_attributes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.i_user_attributes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemRow::~ItemRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.i_name_.Destroy();
  _impl_.i_description_.Destroy();
  _impl_.i_user_attributes_.Destroy();
}

void ItemRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.i_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.i_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.i_user_attributes_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.i_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.i_initial_price_) -
        reinterpret_cast<char*>(&_impl_.i_id_)) + sizeof(_impl_.i_initial_price_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.i_current_price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.i_status_) -
        reinterpret_cast<char*>(&_impl_.i_current_price_)) + sizeof(_impl_.i_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 i_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_i_id(&has_bits);
          _impl_.i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_u_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_i_u_id(&has_bits);
          _impl_.i_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_c_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_i_c_id(&has_bits);
          _impl_.i_c_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string i_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_i_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemRow.i_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string i_description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_i_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemRow.i_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string i_user_attributes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_i_user_attributes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemRow.i_user_attributes");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required double i_initial_price = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_i_initial_price(&has_bits);
          _impl_.i_initial_price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double i_current_price = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_i_current_price(&has_bits);
          _impl_.i_current_price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_num_bids = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_i_num_bids(&has_bits);
          _impl_.i_num_bids_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_num_images = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_i_num_images(&has_bits);
          _impl_.i_num_images_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_num_global_attrs = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_i_num_global_attrs(&has_bits);
          _impl_.i_num_global_attrs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_start_date = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_i_start_date(&has_bits);
          _impl_.i_start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_end_date = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_i_end_date(&has_bits);
          _impl_.i_end_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 i_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_i_status(&has_bits);
          _impl_.i_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 i_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_i_id(), target);
  }

  // required uint32 i_u_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_i_u_id(), target);
  }

  // required uint32 i_c_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_i_c_id(), target);
  }

  // required string i_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_i_name().data(), static_cast<int>(this->_internal_i_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemRow.i_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_i_name(), target);
  }

  // required string i_description = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_i_description().data(), static_cast<int>(this->_internal_i_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemRow.i_description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_i_description(), target);
  }

  // required string i_user_attributes = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_i_user_attributes().data(), static_cast<int>(this->_internal_i_user_attributes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemRow.i_user_attributes");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_i_user_attributes(), target);
  }

  // required double i_initial_price = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_i_initial_price(), target);
  }

  // required double i_current_price = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_i_current_price(), target);
  }

  // required uint32 i_num_bids = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_i_num_bids(), target);
  }

  // required uint32 i_num_images = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_i_num_images(), target);
  }

  // required uint32 i_num_global_attrs = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_i_num_global_attrs(), target);
  }

  // required uint32 i_start_date = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_i_start_date(), target);
  }

  // required uint32 i_end_date = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_i_end_date(), target);
  }

  // required uint32 i_status = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_i_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemRow)
  return target;
}

size_t ItemRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemRow)
  size_t total_size = 0;

  if (_internal_has_i_name()) {
    // required string i_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_name());
  }

  if (_internal_has_i_description()) {
    // required string i_description = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_description());
  }

  if (_internal_has_i_user_attributes()) {
    // required string i_user_attributes = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_user_attributes());
  }

  if (_internal_has_i_id()) {
    // required uint32 i_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_id());
  }

  if (_internal_has_i_u_id()) {
    // required uint32 i_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_u_id());
  }

  if (_internal_has_i_c_id()) {
    // required uint32 i_c_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_c_id());
  }

  if (_internal_has_i_num_bids()) {
    // required uint32 i_num_bids = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_bids());
  }

  if (_internal_has_i_initial_price()) {
    // required double i_initial_price = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_i_current_price()) {
    // required double i_current_price = 8;
    total_size += 1 + 8;
  }

  if (_internal_has_i_num_images()) {
    // required uint32 i_num_images = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_images());
  }

  if (_internal_has_i_num_global_attrs()) {
    // required uint32 i_num_global_attrs = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_global_attrs());
  }

  if (_internal_has_i_start_date()) {
    // required uint32 i_start_date = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_start_date());
  }

  if (_internal_has_i_end_date()) {
    // required uint32 i_end_date = 13;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_end_date());
  }

  if (_internal_has_i_status()) {
    // required uint32 i_status = 14;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_status());
  }

  return total_size;
}
size_t ItemRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00003fff) ^ 0x00003fff) == 0) {  // All required fields are present.
    // required string i_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_name());

    // required string i_description = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_description());

    // required string i_user_attributes = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_i_user_attributes());

    // required uint32 i_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_id());

    // required uint32 i_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_u_id());

    // required uint32 i_c_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_c_id());

    // required uint32 i_num_bids = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_bids());

    // required double i_initial_price = 7;
    total_size += 1 + 8;

    // required double i_current_price = 8;
    total_size += 1 + 8;

    // required uint32 i_num_images = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_images());

    // required uint32 i_num_global_attrs = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_num_global_attrs());

    // required uint32 i_start_date = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_start_date());

    // required uint32 i_end_date = 13;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_end_date());

    // required uint32 i_status = 14;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemRow::GetClassData() const { return &_class_data_; }


void ItemRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemRow*>(&to_msg);
  auto& from = static_cast<const ItemRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_i_name(from._internal_i_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_i_description(from._internal_i_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_i_user_attributes(from._internal_i_user_attributes());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.i_id_ = from._impl_.i_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.i_u_id_ = from._impl_.i_u_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.i_c_id_ = from._impl_.i_c_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.i_num_bids_ = from._impl_.i_num_bids_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.i_initial_price_ = from._impl_.i_initial_price_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.i_current_price_ = from._impl_.i_current_price_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.i_num_images_ = from._impl_.i_num_images_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.i_num_global_attrs_ = from._impl_.i_num_global_attrs_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.i_start_date_ = from._impl_.i_start_date_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.i_end_date_ = from._impl_.i_end_date_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.i_status_ = from._impl_.i_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemRow::CopyFrom(const ItemRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemRow::InternalSwap(ItemRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.i_name_, lhs_arena,
      &other->_impl_.i_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.i_description_, lhs_arena,
      &other->_impl_.i_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.i_user_attributes_, lhs_arena,
      &other->_impl_.i_user_attributes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemRow, _impl_.i_status_)
      + sizeof(ItemRow::_impl_.i_status_)
      - PROTOBUF_FIELD_OFFSET(ItemRow, _impl_.i_id_)>(
          reinterpret_cast<char*>(&_impl_.i_id_),
          reinterpret_cast<char*>(&other->_impl_.i_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[6]);
}

// ===================================================================

class ItemImageRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemImageRow>()._impl_._has_bits_);
  static void set_has_ii_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ii_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ii_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ii_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

ItemImageRow::ItemImageRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemImageRow)
}
ItemImageRow::ItemImageRow(const ItemImageRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemImageRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ii_path_){}
    , decltype(_impl_.ii_id_){}
    , decltype(_impl_.ii_i_id_){}
    , decltype(_impl_.ii_u_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ii_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ii_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ii_path()) {
    _this->_impl_.ii_path_.Set(from._internal_ii_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ii_id_, &from._impl_.ii_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ii_u_id_) -
    reinterpret_cast<char*>(&_impl_.ii_id_)) + sizeof(_impl_.ii_u_id_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemImageRow)
}

inline void ItemImageRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ii_path_){}
    , decltype(_impl_.ii_id_){0u}
    , decltype(_impl_.ii_i_id_){0u}
    , decltype(_impl_.ii_u_id_){0u}
  };
  _impl_.ii_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ii_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemImageRow::~ItemImageRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemImageRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemImageRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ii_path_.Destroy();
}

void ItemImageRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemImageRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemImageRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ii_path_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.ii_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ii_u_id_) -
        reinterpret_cast<char*>(&_impl_.ii_id_)) + sizeof(_impl_.ii_u_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemImageRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ii_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ii_id(&has_bits);
          _impl_.ii_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ii_i_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ii_i_id(&has_bits);
          _impl_.ii_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ii_u_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ii_u_id(&has_bits);
          _impl_.ii_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ii_path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ii_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemImageRow.ii_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemImageRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemImageRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ii_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ii_id(), target);
  }

  // required uint32 ii_i_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ii_i_id(), target);
  }

  // required uint32 ii_u_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ii_u_id(), target);
  }

  // required string ii_path = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ii_path().data(), static_cast<int>(this->_internal_ii_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemImageRow.ii_path");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ii_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemImageRow)
  return target;
}

size_t ItemImageRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemImageRow)
  size_t total_size = 0;

  if (_internal_has_ii_path()) {
    // required string ii_path = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ii_path());
  }

  if (_internal_has_ii_id()) {
    // required uint32 ii_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_id());
  }

  if (_internal_has_ii_i_id()) {
    // required uint32 ii_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_i_id());
  }

  if (_internal_has_ii_u_id()) {
    // required uint32 ii_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_u_id());
  }

  return total_size;
}
size_t ItemImageRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemImageRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string ii_path = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ii_path());

    // required uint32 ii_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_id());

    // required uint32 ii_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_i_id());

    // required uint32 ii_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ii_u_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemImageRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemImageRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemImageRow::GetClassData() const { return &_class_data_; }


void ItemImageRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemImageRow*>(&to_msg);
  auto& from = static_cast<const ItemImageRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemImageRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ii_path(from._internal_ii_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ii_id_ = from._impl_.ii_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ii_i_id_ = from._impl_.ii_i_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ii_u_id_ = from._impl_.ii_u_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemImageRow::CopyFrom(const ItemImageRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemImageRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemImageRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemImageRow::InternalSwap(ItemImageRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ii_path_, lhs_arena,
      &other->_impl_.ii_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemImageRow, _impl_.ii_u_id_)
      + sizeof(ItemImageRow::_impl_.ii_u_id_)
      - PROTOBUF_FIELD_OFFSET(ItemImageRow, _impl_.ii_id_)>(
          reinterpret_cast<char*>(&_impl_.ii_id_),
          reinterpret_cast<char*>(&other->_impl_.ii_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemImageRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[7]);
}

// ===================================================================

class ItemCommentRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemCommentRow>()._impl_._has_bits_);
  static void set_has_ic_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ic_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ic_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ic_buyer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ic_date(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ic_question(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ic_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

ItemCommentRow::ItemCommentRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemCommentRow)
}
ItemCommentRow::ItemCommentRow(const ItemCommentRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemCommentRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ic_question_){}
    , decltype(_impl_.ic_response_){}
    , decltype(_impl_.ic_id_){}
    , decltype(_impl_.ic_i_id_){}
    , decltype(_impl_.ic_u_id_){}
    , decltype(_impl_.ic_buyer_id_){}
    , decltype(_impl_.ic_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ic_question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ic_question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ic_question()) {
    _this->_impl_.ic_question_.Set(from._internal_ic_question(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ic_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ic_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ic_response()) {
    _this->_impl_.ic_response_.Set(from._internal_ic_response(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ic_id_, &from._impl_.ic_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ic_date_) -
    reinterpret_cast<char*>(&_impl_.ic_id_)) + sizeof(_impl_.ic_date_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemCommentRow)
}

inline void ItemCommentRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ic_question_){}
    , decltype(_impl_.ic_response_){}
    , decltype(_impl_.ic_id_){0u}
    , decltype(_impl_.ic_i_id_){0u}
    , decltype(_impl_.ic_u_id_){0u}
    , decltype(_impl_.ic_buyer_id_){0u}
    , decltype(_impl_.ic_date_){0u}
  };
  _impl_.ic_question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ic_question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ic_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ic_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemCommentRow::~ItemCommentRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemCommentRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemCommentRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ic_question_.Destroy();
  _impl_.ic_response_.Destroy();
}

void ItemCommentRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemCommentRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemCommentRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ic_question_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ic_response_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.ic_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ic_date_) -
        reinterpret_cast<char*>(&_impl_.ic_id_)) + sizeof(_impl_.ic_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemCommentRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ic_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ic_id(&has_bits);
          _impl_.ic_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ic_i_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ic_i_id(&has_bits);
          _impl_.ic_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ic_u_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ic_u_id(&has_bits);
          _impl_.ic_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ic_buyer_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ic_buyer_id(&has_bits);
          _impl_.ic_buyer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ic_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ic_date(&has_bits);
          _impl_.ic_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ic_question = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_ic_question();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemCommentRow.ic_question");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ic_response = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_ic_response();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemCommentRow.ic_response");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemCommentRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemCommentRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ic_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ic_id(), target);
  }

  // required uint32 ic_i_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ic_i_id(), target);
  }

  // required uint32 ic_u_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ic_u_id(), target);
  }

  // required uint32 ic_buyer_id = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ic_buyer_id(), target);
  }

  // required uint32 ic_date = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ic_date(), target);
  }

  // required string ic_question = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ic_question().data(), static_cast<int>(this->_internal_ic_question().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemCommentRow.ic_question");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_ic_question(), target);
  }

  // required string ic_response = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ic_response().data(), static_cast<int>(this->_internal_ic_response().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemCommentRow.ic_response");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_ic_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemCommentRow)
  return target;
}

size_t ItemCommentRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemCommentRow)
  size_t total_size = 0;

  if (_internal_has_ic_question()) {
    // required string ic_question = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ic_question());
  }

  if (_internal_has_ic_response()) {
    // required string ic_response = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ic_response());
  }

  if (_internal_has_ic_id()) {
    // required uint32 ic_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_id());
  }

  if (_internal_has_ic_i_id()) {
    // required uint32 ic_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_i_id());
  }

  if (_internal_has_ic_u_id()) {
    // required uint32 ic_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_u_id());
  }

  if (_internal_has_ic_buyer_id()) {
    // required uint32 ic_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_buyer_id());
  }

  if (_internal_has_ic_date()) {
    // required uint32 ic_date = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_date());
  }

  return total_size;
}
size_t ItemCommentRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemCommentRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string ic_question = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ic_question());

    // required string ic_response = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ic_response());

    // required uint32 ic_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_id());

    // required uint32 ic_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_i_id());

    // required uint32 ic_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_u_id());

    // required uint32 ic_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_buyer_id());

    // required uint32 ic_date = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ic_date());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemCommentRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemCommentRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemCommentRow::GetClassData() const { return &_class_data_; }


void ItemCommentRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemCommentRow*>(&to_msg);
  auto& from = static_cast<const ItemCommentRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemCommentRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ic_question(from._internal_ic_question());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ic_response(from._internal_ic_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ic_id_ = from._impl_.ic_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ic_i_id_ = from._impl_.ic_i_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ic_u_id_ = from._impl_.ic_u_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ic_buyer_id_ = from._impl_.ic_buyer_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ic_date_ = from._impl_.ic_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemCommentRow::CopyFrom(const ItemCommentRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemCommentRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemCommentRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemCommentRow::InternalSwap(ItemCommentRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ic_question_, lhs_arena,
      &other->_impl_.ic_question_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ic_response_, lhs_arena,
      &other->_impl_.ic_response_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemCommentRow, _impl_.ic_date_)
      + sizeof(ItemCommentRow::_impl_.ic_date_)
      - PROTOBUF_FIELD_OFFSET(ItemCommentRow, _impl_.ic_id_)>(
          reinterpret_cast<char*>(&_impl_.ic_id_),
          reinterpret_cast<char*>(&other->_impl_.ic_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemCommentRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[8]);
}

// ===================================================================

class ItemFeedbackRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemFeedbackRow>()._impl_._has_bits_);
  static void set_has_if_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_if_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_if_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_if_buyer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_if_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_if_date(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_if_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

ItemFeedbackRow::ItemFeedbackRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemFeedbackRow)
}
ItemFeedbackRow::ItemFeedbackRow(const ItemFeedbackRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemFeedbackRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.if_comment_){}
    , decltype(_impl_.if_id_){}
    , decltype(_impl_.if_i_id_){}
    , decltype(_impl_.if_u_id_){}
    , decltype(_impl_.if_buyer_id_){}
    , decltype(_impl_.if_rating_){}
    , decltype(_impl_.if_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.if_comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.if_comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_if_comment()) {
    _this->_impl_.if_comment_.Set(from._internal_if_comment(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.if_id_, &from._impl_.if_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.if_date_) -
    reinterpret_cast<char*>(&_impl_.if_id_)) + sizeof(_impl_.if_date_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemFeedbackRow)
}

inline void ItemFeedbackRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.if_comment_){}
    , decltype(_impl_.if_id_){0u}
    , decltype(_impl_.if_i_id_){0u}
    , decltype(_impl_.if_u_id_){0u}
    , decltype(_impl_.if_buyer_id_){0u}
    , decltype(_impl_.if_rating_){0u}
    , decltype(_impl_.if_date_){0u}
  };
  _impl_.if_comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.if_comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ItemFeedbackRow::~ItemFeedbackRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemFeedbackRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemFeedbackRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.if_comment_.Destroy();
}

void ItemFeedbackRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemFeedbackRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemFeedbackRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.if_comment_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.if_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.if_date_) -
        reinterpret_cast<char*>(&_impl_.if_id_)) + sizeof(_impl_.if_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemFeedbackRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 if_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_if_id(&has_bits);
          _impl_.if_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 if_i_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_if_i_id(&has_bits);
          _impl_.if_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 if_u_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_if_u_id(&has_bits);
          _impl_.if_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 if_buyer_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_if_buyer_id(&has_bits);
          _impl_.if_buyer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 if_rating = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_if_rating(&has_bits);
          _impl_.if_rating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 if_date = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_if_date(&has_bits);
          _impl_.if_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string if_comment = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_if_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "auctionmark.ItemFeedbackRow.if_comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemFeedbackRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemFeedbackRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 if_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_if_id(), target);
  }

  // required uint32 if_i_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_if_i_id(), target);
  }

  // required uint32 if_u_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_if_u_id(), target);
  }

  // required uint32 if_buyer_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_if_buyer_id(), target);
  }

  // required uint32 if_rating = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_if_rating(), target);
  }

  // required uint32 if_date = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_if_date(), target);
  }

  // required string if_comment = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_if_comment().data(), static_cast<int>(this->_internal_if_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "auctionmark.ItemFeedbackRow.if_comment");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_if_comment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemFeedbackRow)
  return target;
}

size_t ItemFeedbackRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemFeedbackRow)
  size_t total_size = 0;

  if (_internal_has_if_comment()) {
    // required string if_comment = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_if_comment());
  }

  if (_internal_has_if_id()) {
    // required uint32 if_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_id());
  }

  if (_internal_has_if_i_id()) {
    // required uint32 if_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_i_id());
  }

  if (_internal_has_if_u_id()) {
    // required uint32 if_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_u_id());
  }

  if (_internal_has_if_buyer_id()) {
    // required uint32 if_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_buyer_id());
  }

  if (_internal_has_if_rating()) {
    // required uint32 if_rating = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_rating());
  }

  if (_internal_has_if_date()) {
    // required uint32 if_date = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_date());
  }

  return total_size;
}
size_t ItemFeedbackRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemFeedbackRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string if_comment = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_if_comment());

    // required uint32 if_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_id());

    // required uint32 if_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_i_id());

    // required uint32 if_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_u_id());

    // required uint32 if_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_buyer_id());

    // required uint32 if_rating = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_rating());

    // required uint32 if_date = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_date());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemFeedbackRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemFeedbackRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemFeedbackRow::GetClassData() const { return &_class_data_; }


void ItemFeedbackRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemFeedbackRow*>(&to_msg);
  auto& from = static_cast<const ItemFeedbackRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemFeedbackRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_if_comment(from._internal_if_comment());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.if_id_ = from._impl_.if_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.if_i_id_ = from._impl_.if_i_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.if_u_id_ = from._impl_.if_u_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.if_buyer_id_ = from._impl_.if_buyer_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.if_rating_ = from._impl_.if_rating_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.if_date_ = from._impl_.if_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemFeedbackRow::CopyFrom(const ItemFeedbackRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemFeedbackRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemFeedbackRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemFeedbackRow::InternalSwap(ItemFeedbackRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.if_comment_, lhs_arena,
      &other->_impl_.if_comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemFeedbackRow, _impl_.if_date_)
      + sizeof(ItemFeedbackRow::_impl_.if_date_)
      - PROTOBUF_FIELD_OFFSET(ItemFeedbackRow, _impl_.if_id_)>(
          reinterpret_cast<char*>(&_impl_.if_id_),
          reinterpret_cast<char*>(&other->_impl_.if_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemFeedbackRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[9]);
}

// ===================================================================

class ItemBidRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemBidRow>()._impl_._has_bits_);
  static void set_has_ib_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ib_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ib_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ib_buyer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ib_bid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ib_max_bid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ib_created(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ib_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

ItemBidRow::ItemBidRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemBidRow)
}
ItemBidRow::ItemBidRow(const ItemBidRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemBidRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ib_id_){}
    , decltype(_impl_.ib_i_id_){}
    , decltype(_impl_.ib_u_id_){}
    , decltype(_impl_.ib_buyer_id_){}
    , decltype(_impl_.ib_bid_){}
    , decltype(_impl_.ib_max_bid_){}
    , decltype(_impl_.ib_created_){}
    , decltype(_impl_.ib_updated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ib_id_, &from._impl_.ib_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ib_updated_) -
    reinterpret_cast<char*>(&_impl_.ib_id_)) + sizeof(_impl_.ib_updated_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemBidRow)
}

inline void ItemBidRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ib_id_){0u}
    , decltype(_impl_.ib_i_id_){0u}
    , decltype(_impl_.ib_u_id_){0u}
    , decltype(_impl_.ib_buyer_id_){0u}
    , decltype(_impl_.ib_bid_){0}
    , decltype(_impl_.ib_max_bid_){0}
    , decltype(_impl_.ib_created_){0u}
    , decltype(_impl_.ib_updated_){0u}
  };
}

ItemBidRow::~ItemBidRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemBidRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemBidRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ItemBidRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemBidRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemBidRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.ib_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ib_updated_) -
        reinterpret_cast<char*>(&_impl_.ib_id_)) + sizeof(_impl_.ib_updated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemBidRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ib_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ib_id(&has_bits);
          _impl_.ib_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ib_i_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ib_i_id(&has_bits);
          _impl_.ib_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ib_u_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ib_u_id(&has_bits);
          _impl_.ib_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ib_buyer_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ib_buyer_id(&has_bits);
          _impl_.ib_buyer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double ib_bid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_ib_bid(&has_bits);
          _impl_.ib_bid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double ib_max_bid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_ib_max_bid(&has_bits);
          _impl_.ib_max_bid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ib_created = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ib_created(&has_bits);
          _impl_.ib_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ib_updated = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ib_updated(&has_bits);
          _impl_.ib_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemBidRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemBidRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ib_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ib_id(), target);
  }

  // required uint32 ib_i_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ib_i_id(), target);
  }

  // required uint32 ib_u_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ib_u_id(), target);
  }

  // required uint32 ib_buyer_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ib_buyer_id(), target);
  }

  // required double ib_bid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_ib_bid(), target);
  }

  // required double ib_max_bid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_ib_max_bid(), target);
  }

  // required uint32 ib_created = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_ib_created(), target);
  }

  // required uint32 ib_updated = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_ib_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemBidRow)
  return target;
}

size_t ItemBidRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemBidRow)
  size_t total_size = 0;

  if (_internal_has_ib_id()) {
    // required uint32 ib_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_id());
  }

  if (_internal_has_ib_i_id()) {
    // required uint32 ib_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_i_id());
  }

  if (_internal_has_ib_u_id()) {
    // required uint32 ib_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_u_id());
  }

  if (_internal_has_ib_buyer_id()) {
    // required uint32 ib_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_buyer_id());
  }

  if (_internal_has_ib_bid()) {
    // required double ib_bid = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_ib_max_bid()) {
    // required double ib_max_bid = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_ib_created()) {
    // required uint32 ib_created = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_created());
  }

  if (_internal_has_ib_updated()) {
    // required uint32 ib_updated = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_updated());
  }

  return total_size;
}
size_t ItemBidRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemBidRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required uint32 ib_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_id());

    // required uint32 ib_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_i_id());

    // required uint32 ib_u_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_u_id());

    // required uint32 ib_buyer_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_buyer_id());

    // required double ib_bid = 5;
    total_size += 1 + 8;

    // required double ib_max_bid = 6;
    total_size += 1 + 8;

    // required uint32 ib_created = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_created());

    // required uint32 ib_updated = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ib_updated());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemBidRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemBidRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemBidRow::GetClassData() const { return &_class_data_; }


void ItemBidRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemBidRow*>(&to_msg);
  auto& from = static_cast<const ItemBidRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemBidRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ib_id_ = from._impl_.ib_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ib_i_id_ = from._impl_.ib_i_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ib_u_id_ = from._impl_.ib_u_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ib_buyer_id_ = from._impl_.ib_buyer_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ib_bid_ = from._impl_.ib_bid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ib_max_bid_ = from._impl_.ib_max_bid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ib_created_ = from._impl_.ib_created_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ib_updated_ = from._impl_.ib_updated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemBidRow::CopyFrom(const ItemBidRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemBidRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemBidRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemBidRow::InternalSwap(ItemBidRow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemBidRow, _impl_.ib_updated_)
      + sizeof(ItemBidRow::_impl_.ib_updated_)
      - PROTOBUF_FIELD_OFFSET(ItemBidRow, _impl_.ib_id_)>(
          reinterpret_cast<char*>(&_impl_.ib_id_),
          reinterpret_cast<char*>(&other->_impl_.ib_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemBidRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[10]);
}

// ===================================================================

class ItemMaxBidRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemMaxBidRow>()._impl_._has_bits_);
  static void set_has_imb_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_imb_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_imb_ib_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_imb_ib_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_imb_ib_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_imb_created(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_imb_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

ItemMaxBidRow::ItemMaxBidRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemMaxBidRow)
}
ItemMaxBidRow::ItemMaxBidRow(const ItemMaxBidRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemMaxBidRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imb_i_id_){}
    , decltype(_impl_.imb_u_id_){}
    , decltype(_impl_.imb_ib_id_){}
    , decltype(_impl_.imb_ib_i_id_){}
    , decltype(_impl_.imb_ib_u_id_){}
    , decltype(_impl_.imb_created_){}
    , decltype(_impl_.imb_updated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.imb_i_id_, &from._impl_.imb_i_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.imb_updated_) -
    reinterpret_cast<char*>(&_impl_.imb_i_id_)) + sizeof(_impl_.imb_updated_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemMaxBidRow)
}

inline void ItemMaxBidRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imb_i_id_){0u}
    , decltype(_impl_.imb_u_id_){0u}
    , decltype(_impl_.imb_ib_id_){0u}
    , decltype(_impl_.imb_ib_i_id_){0u}
    , decltype(_impl_.imb_ib_u_id_){0u}
    , decltype(_impl_.imb_created_){0u}
    , decltype(_impl_.imb_updated_){0u}
  };
}

ItemMaxBidRow::~ItemMaxBidRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemMaxBidRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemMaxBidRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ItemMaxBidRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemMaxBidRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemMaxBidRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.imb_i_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.imb_updated_) -
        reinterpret_cast<char*>(&_impl_.imb_i_id_)) + sizeof(_impl_.imb_updated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemMaxBidRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 imb_i_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_imb_i_id(&has_bits);
          _impl_.imb_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_u_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_imb_u_id(&has_bits);
          _impl_.imb_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_ib_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_imb_ib_id(&has_bits);
          _impl_.imb_ib_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_ib_i_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_imb_ib_i_id(&has_bits);
          _impl_.imb_ib_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_ib_u_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_imb_ib_u_id(&has_bits);
          _impl_.imb_ib_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_created = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_imb_created(&has_bits);
          _impl_.imb_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 imb_updated = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_imb_updated(&has_bits);
          _impl_.imb_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemMaxBidRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemMaxBidRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 imb_i_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_imb_i_id(), target);
  }

  // required uint32 imb_u_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_imb_u_id(), target);
  }

  // required uint32 imb_ib_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_imb_ib_id(), target);
  }

  // required uint32 imb_ib_i_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_imb_ib_i_id(), target);
  }

  // required uint32 imb_ib_u_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_imb_ib_u_id(), target);
  }

  // required uint32 imb_created = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_imb_created(), target);
  }

  // required uint32 imb_updated = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_imb_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemMaxBidRow)
  return target;
}

size_t ItemMaxBidRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemMaxBidRow)
  size_t total_size = 0;

  if (_internal_has_imb_i_id()) {
    // required uint32 imb_i_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_i_id());
  }

  if (_internal_has_imb_u_id()) {
    // required uint32 imb_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_u_id());
  }

  if (_internal_has_imb_ib_id()) {
    // required uint32 imb_ib_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_id());
  }

  if (_internal_has_imb_ib_i_id()) {
    // required uint32 imb_ib_i_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_i_id());
  }

  if (_internal_has_imb_ib_u_id()) {
    // required uint32 imb_ib_u_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_u_id());
  }

  if (_internal_has_imb_created()) {
    // required uint32 imb_created = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_created());
  }

  if (_internal_has_imb_updated()) {
    // required uint32 imb_updated = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_updated());
  }

  return total_size;
}
size_t ItemMaxBidRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemMaxBidRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required uint32 imb_i_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_i_id());

    // required uint32 imb_u_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_u_id());

    // required uint32 imb_ib_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_id());

    // required uint32 imb_ib_i_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_i_id());

    // required uint32 imb_ib_u_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_ib_u_id());

    // required uint32 imb_created = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_created());

    // required uint32 imb_updated = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_imb_updated());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemMaxBidRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemMaxBidRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemMaxBidRow::GetClassData() const { return &_class_data_; }


void ItemMaxBidRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemMaxBidRow*>(&to_msg);
  auto& from = static_cast<const ItemMaxBidRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemMaxBidRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.imb_i_id_ = from._impl_.imb_i_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.imb_u_id_ = from._impl_.imb_u_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.imb_ib_id_ = from._impl_.imb_ib_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.imb_ib_i_id_ = from._impl_.imb_ib_i_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.imb_ib_u_id_ = from._impl_.imb_ib_u_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.imb_created_ = from._impl_.imb_created_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.imb_updated_ = from._impl_.imb_updated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemMaxBidRow::CopyFrom(const ItemMaxBidRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemMaxBidRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemMaxBidRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemMaxBidRow::InternalSwap(ItemMaxBidRow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemMaxBidRow, _impl_.imb_updated_)
      + sizeof(ItemMaxBidRow::_impl_.imb_updated_)
      - PROTOBUF_FIELD_OFFSET(ItemMaxBidRow, _impl_.imb_i_id_)>(
          reinterpret_cast<char*>(&_impl_.imb_i_id_),
          reinterpret_cast<char*>(&other->_impl_.imb_i_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemMaxBidRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[11]);
}

// ===================================================================

class ItemPurchaseRow::_Internal {
 public:
  using HasBits = decltype(std::declval<ItemPurchaseRow>()._impl_._has_bits_);
  static void set_has_ip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip_ib_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ip_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ip_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

ItemPurchaseRow::ItemPurchaseRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.ItemPurchaseRow)
}
ItemPurchaseRow::ItemPurchaseRow(const ItemPurchaseRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemPurchaseRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_id_){}
    , decltype(_impl_.ip_ib_id_){}
    , decltype(_impl_.ip_i_id_){}
    , decltype(_impl_.ip_u_id_){}
    , decltype(_impl_.ip_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ip_id_, &from._impl_.ip_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ip_date_) -
    reinterpret_cast<char*>(&_impl_.ip_id_)) + sizeof(_impl_.ip_date_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.ItemPurchaseRow)
}

inline void ItemPurchaseRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_id_){0u}
    , decltype(_impl_.ip_ib_id_){0u}
    , decltype(_impl_.ip_i_id_){0u}
    , decltype(_impl_.ip_u_id_){0u}
    , decltype(_impl_.ip_date_){0u}
  };
}

ItemPurchaseRow::~ItemPurchaseRow() {
  // @@protoc_insertion_point(destructor:auctionmark.ItemPurchaseRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemPurchaseRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ItemPurchaseRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemPurchaseRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.ItemPurchaseRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.ip_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ip_date_) -
        reinterpret_cast<char*>(&_impl_.ip_id_)) + sizeof(_impl_.ip_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemPurchaseRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ip_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ip_id(&has_bits);
          _impl_.ip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ip_ib_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ip_ib_id(&has_bits);
          _impl_.ip_ib_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ip_i_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ip_i_id(&has_bits);
          _impl_.ip_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ip_u_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ip_u_id(&has_bits);
          _impl_.ip_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ip_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ip_date(&has_bits);
          _impl_.ip_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemPurchaseRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.ItemPurchaseRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ip_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ip_id(), target);
  }

  // required uint32 ip_ib_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ip_ib_id(), target);
  }

  // required uint32 ip_i_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ip_i_id(), target);
  }

  // required uint32 ip_u_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ip_u_id(), target);
  }

  // required uint32 ip_date = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ip_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.ItemPurchaseRow)
  return target;
}

size_t ItemPurchaseRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.ItemPurchaseRow)
  size_t total_size = 0;

  if (_internal_has_ip_id()) {
    // required uint32 ip_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_id());
  }

  if (_internal_has_ip_ib_id()) {
    // required uint32 ip_ib_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_ib_id());
  }

  if (_internal_has_ip_i_id()) {
    // required uint32 ip_i_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_i_id());
  }

  if (_internal_has_ip_u_id()) {
    // required uint32 ip_u_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_u_id());
  }

  if (_internal_has_ip_date()) {
    // required uint32 ip_date = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_date());
  }

  return total_size;
}
size_t ItemPurchaseRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.ItemPurchaseRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 ip_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_id());

    // required uint32 ip_ib_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_ib_id());

    // required uint32 ip_i_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_i_id());

    // required uint32 ip_u_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_u_id());

    // required uint32 ip_date = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_date());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemPurchaseRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemPurchaseRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemPurchaseRow::GetClassData() const { return &_class_data_; }


void ItemPurchaseRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemPurchaseRow*>(&to_msg);
  auto& from = static_cast<const ItemPurchaseRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.ItemPurchaseRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ip_id_ = from._impl_.ip_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_ib_id_ = from._impl_.ip_ib_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ip_i_id_ = from._impl_.ip_i_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ip_u_id_ = from._impl_.ip_u_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ip_date_ = from._impl_.ip_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemPurchaseRow::CopyFrom(const ItemPurchaseRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.ItemPurchaseRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemPurchaseRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ItemPurchaseRow::InternalSwap(ItemPurchaseRow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemPurchaseRow, _impl_.ip_date_)
      + sizeof(ItemPurchaseRow::_impl_.ip_date_)
      - PROTOBUF_FIELD_OFFSET(ItemPurchaseRow, _impl_.ip_id_)>(
          reinterpret_cast<char*>(&_impl_.ip_id_),
          reinterpret_cast<char*>(&other->_impl_.ip_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemPurchaseRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[12]);
}

// ===================================================================

class UserItemRow::_Internal {
 public:
  using HasBits = decltype(std::declval<UserItemRow>()._impl_._has_bits_);
  static void set_has_ui_u_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ui_i_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ui_seller_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ui_created(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

UserItemRow::UserItemRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:auctionmark.UserItemRow)
}
UserItemRow::UserItemRow(const UserItemRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserItemRow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ui_u_id_){}
    , decltype(_impl_.ui_i_id_){}
    , decltype(_impl_.ui_seller_id_){}
    , decltype(_impl_.ui_created_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ui_u_id_, &from._impl_.ui_u_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ui_created_) -
    reinterpret_cast<char*>(&_impl_.ui_u_id_)) + sizeof(_impl_.ui_created_));
  // @@protoc_insertion_point(copy_constructor:auctionmark.UserItemRow)
}

inline void UserItemRow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ui_u_id_){0u}
    , decltype(_impl_.ui_i_id_){0u}
    , decltype(_impl_.ui_seller_id_){0u}
    , decltype(_impl_.ui_created_){0u}
  };
}

UserItemRow::~UserItemRow() {
  // @@protoc_insertion_point(destructor:auctionmark.UserItemRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserItemRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserItemRow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserItemRow::Clear() {
// @@protoc_insertion_point(message_clear_start:auctionmark.UserItemRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.ui_u_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ui_created_) -
        reinterpret_cast<char*>(&_impl_.ui_u_id_)) + sizeof(_impl_.ui_created_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserItemRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ui_u_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ui_u_id(&has_bits);
          _impl_.ui_u_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ui_i_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ui_i_id(&has_bits);
          _impl_.ui_i_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ui_seller_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ui_seller_id(&has_bits);
          _impl_.ui_seller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ui_created = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ui_created(&has_bits);
          _impl_.ui_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserItemRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:auctionmark.UserItemRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ui_u_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ui_u_id(), target);
  }

  // required uint32 ui_i_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ui_i_id(), target);
  }

  // required uint32 ui_seller_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ui_seller_id(), target);
  }

  // required uint32 ui_created = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ui_created(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:auctionmark.UserItemRow)
  return target;
}

size_t UserItemRow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:auctionmark.UserItemRow)
  size_t total_size = 0;

  if (_internal_has_ui_u_id()) {
    // required uint32 ui_u_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_u_id());
  }

  if (_internal_has_ui_i_id()) {
    // required uint32 ui_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_i_id());
  }

  if (_internal_has_ui_seller_id()) {
    // required uint32 ui_seller_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_seller_id());
  }

  if (_internal_has_ui_created()) {
    // required uint32 ui_created = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_created());
  }

  return total_size;
}
size_t UserItemRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:auctionmark.UserItemRow)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 ui_u_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_u_id());

    // required uint32 ui_i_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_i_id());

    // required uint32 ui_seller_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_seller_id());

    // required uint32 ui_created = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ui_created());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserItemRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserItemRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserItemRow::GetClassData() const { return &_class_data_; }


void UserItemRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserItemRow*>(&to_msg);
  auto& from = static_cast<const UserItemRow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:auctionmark.UserItemRow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ui_u_id_ = from._impl_.ui_u_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ui_i_id_ = from._impl_.ui_i_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ui_seller_id_ = from._impl_.ui_seller_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ui_created_ = from._impl_.ui_created_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserItemRow::CopyFrom(const UserItemRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:auctionmark.UserItemRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserItemRow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserItemRow::InternalSwap(UserItemRow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserItemRow, _impl_.ui_created_)
      + sizeof(UserItemRow::_impl_.ui_created_)
      - PROTOBUF_FIELD_OFFSET(UserItemRow, _impl_.ui_u_id_)>(
          reinterpret_cast<char*>(&_impl_.ui_u_id_),
          reinterpret_cast<char*>(&other->_impl_.ui_u_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserItemRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_auctionmark_2eproto_getter, &descriptor_table_auctionmark_2eproto_once,
      file_level_metadata_auctionmark_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace auctionmark
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::auctionmark::RegionRow*
Arena::CreateMaybeMessage< ::auctionmark::RegionRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::RegionRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::GlobalAttributeGroupRow*
Arena::CreateMaybeMessage< ::auctionmark::GlobalAttributeGroupRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::GlobalAttributeGroupRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::GlobalAttributeValueRow*
Arena::CreateMaybeMessage< ::auctionmark::GlobalAttributeValueRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::GlobalAttributeValueRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::CategoryRow*
Arena::CreateMaybeMessage< ::auctionmark::CategoryRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::CategoryRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::UserRow*
Arena::CreateMaybeMessage< ::auctionmark::UserRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::UserRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::UserAttributeRow*
Arena::CreateMaybeMessage< ::auctionmark::UserAttributeRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::UserAttributeRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemImageRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemImageRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemImageRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemCommentRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemCommentRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemCommentRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemFeedbackRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemFeedbackRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemFeedbackRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemBidRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemBidRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemBidRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemMaxBidRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemMaxBidRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemMaxBidRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::ItemPurchaseRow*
Arena::CreateMaybeMessage< ::auctionmark::ItemPurchaseRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::ItemPurchaseRow >(arena);
}
template<> PROTOBUF_NOINLINE ::auctionmark::UserItemRow*
Arena::CreateMaybeMessage< ::auctionmark::UserItemRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::auctionmark::UserItemRow >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

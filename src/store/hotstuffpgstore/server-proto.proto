syntax = "proto2";

import "store/common/common-proto.proto";
import "store/common/query_result/query-result-proto.proto";
import "store/hotstuffpgstore/pbft-proto.proto";

package hotstuffpgstore.proto;

message SQL_RPC {
  required uint64 req_id = 1;
  required bytes query = 2;
  required TimestampMessage timestamp = 3;
  required uint64 client_id = 4;
  required uint64 txn_seq_num = 5;
}

message TryCommit {
  required uint64 req_id = 1;
  required TimestampMessage timestamp = 2;
  required uint64 client_id = 3;
  required uint64 txn_seq_num = 4;
}

message UserAbort {
  required uint64 client_id = 1;
  required uint64 txn_seq_num = 2;
}

message CommitProof {
  // The commit proof will be a writeback message containing proof that
  // all participating shards committed the tx
  required GroupedDecision writeback_message = 1;
  // the commit proof only contains the tx  txn bytes and the key,value pair must be in the txn's write set
  // The proof that the value was actually committed
  // Could still be stale though (i.e. not most recent)
  required Transaction txn = 2;
}

message SQL_RPCReply {
  required uint64 req_id = 1;
  required int32 status = 2;
  optional bytes sql_res = 3;
}

message TryCommitReply {
  required uint64 req_id = 1;
  required int32 status = 2;
}

// This is the request sent to the replication layer
message Transaction {
  repeated ReadMessage readset = 1;
  repeated WriteMessage writeset = 2;
  repeated QueryMessage queryset = 3;
  required TimestampMessage timestamp = 4;
  repeated uint64 participating_shards = 5;
}

message ShardSignedDecisions {
  // Map from shard id to the shard decsion along with f+1 signatures for that decision
  map<uint64, GroupedSignedMessage> grouped_decisions = 1;
}


// Possibly remove all from here down (after removing them from the used structs above):

// This is the reply that a shard sends to the client after it finished its
// CCC
message TransactionDecision {
  // the status of the CCC (Commit/Abort)
  required int32 status = 1;
  // the digest of the transaction that was checked
  required bytes txn_digest = 2;
  // the id of the shard that sent the request
  required uint64 shard_id = 3;
}

message ShardDecisions {
  // when we don't have signatures it doesn't make sense to
  // send f+1 copies of the transaction decision
  // Map from shard id to the transaction decision (should have gotten f+1 of these)
  map<uint64, TransactionDecision> grouped_decisions = 1;
}

// The collected decisions from all shards
message GroupedDecision {
  // the status of the collective decision (Commit/Abort)
  required int32 status = 1;
  required bytes txn_digest = 2;
  oneof decisions_oneof {
    ShardDecisions decisions = 3;
    ShardSignedDecisions signed_decisions = 4;
  }
  required uint64 client_id = 5;
  required uint64 txn_seq_num = 6;
}

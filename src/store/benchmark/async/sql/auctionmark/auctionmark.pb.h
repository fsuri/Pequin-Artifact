// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auctionmark.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_auctionmark_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_auctionmark_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_auctionmark_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_auctionmark_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_auctionmark_2eproto;
namespace auctionmark {
class CategoryRow;
struct CategoryRowDefaultTypeInternal;
extern CategoryRowDefaultTypeInternal _CategoryRow_default_instance_;
class GlobalAttributeGroupRow;
struct GlobalAttributeGroupRowDefaultTypeInternal;
extern GlobalAttributeGroupRowDefaultTypeInternal _GlobalAttributeGroupRow_default_instance_;
class GlobalAttributeValueRow;
struct GlobalAttributeValueRowDefaultTypeInternal;
extern GlobalAttributeValueRowDefaultTypeInternal _GlobalAttributeValueRow_default_instance_;
class ItemBidRow;
struct ItemBidRowDefaultTypeInternal;
extern ItemBidRowDefaultTypeInternal _ItemBidRow_default_instance_;
class ItemCommentRow;
struct ItemCommentRowDefaultTypeInternal;
extern ItemCommentRowDefaultTypeInternal _ItemCommentRow_default_instance_;
class ItemFeedbackRow;
struct ItemFeedbackRowDefaultTypeInternal;
extern ItemFeedbackRowDefaultTypeInternal _ItemFeedbackRow_default_instance_;
class ItemImageRow;
struct ItemImageRowDefaultTypeInternal;
extern ItemImageRowDefaultTypeInternal _ItemImageRow_default_instance_;
class ItemMaxBidRow;
struct ItemMaxBidRowDefaultTypeInternal;
extern ItemMaxBidRowDefaultTypeInternal _ItemMaxBidRow_default_instance_;
class ItemPurchaseRow;
struct ItemPurchaseRowDefaultTypeInternal;
extern ItemPurchaseRowDefaultTypeInternal _ItemPurchaseRow_default_instance_;
class ItemRow;
struct ItemRowDefaultTypeInternal;
extern ItemRowDefaultTypeInternal _ItemRow_default_instance_;
class RegionRow;
struct RegionRowDefaultTypeInternal;
extern RegionRowDefaultTypeInternal _RegionRow_default_instance_;
class UserAttributeRow;
struct UserAttributeRowDefaultTypeInternal;
extern UserAttributeRowDefaultTypeInternal _UserAttributeRow_default_instance_;
class UserItemRow;
struct UserItemRowDefaultTypeInternal;
extern UserItemRowDefaultTypeInternal _UserItemRow_default_instance_;
class UserRow;
struct UserRowDefaultTypeInternal;
extern UserRowDefaultTypeInternal _UserRow_default_instance_;
}  // namespace auctionmark
PROTOBUF_NAMESPACE_OPEN
template<> ::auctionmark::CategoryRow* Arena::CreateMaybeMessage<::auctionmark::CategoryRow>(Arena*);
template<> ::auctionmark::GlobalAttributeGroupRow* Arena::CreateMaybeMessage<::auctionmark::GlobalAttributeGroupRow>(Arena*);
template<> ::auctionmark::GlobalAttributeValueRow* Arena::CreateMaybeMessage<::auctionmark::GlobalAttributeValueRow>(Arena*);
template<> ::auctionmark::ItemBidRow* Arena::CreateMaybeMessage<::auctionmark::ItemBidRow>(Arena*);
template<> ::auctionmark::ItemCommentRow* Arena::CreateMaybeMessage<::auctionmark::ItemCommentRow>(Arena*);
template<> ::auctionmark::ItemFeedbackRow* Arena::CreateMaybeMessage<::auctionmark::ItemFeedbackRow>(Arena*);
template<> ::auctionmark::ItemImageRow* Arena::CreateMaybeMessage<::auctionmark::ItemImageRow>(Arena*);
template<> ::auctionmark::ItemMaxBidRow* Arena::CreateMaybeMessage<::auctionmark::ItemMaxBidRow>(Arena*);
template<> ::auctionmark::ItemPurchaseRow* Arena::CreateMaybeMessage<::auctionmark::ItemPurchaseRow>(Arena*);
template<> ::auctionmark::ItemRow* Arena::CreateMaybeMessage<::auctionmark::ItemRow>(Arena*);
template<> ::auctionmark::RegionRow* Arena::CreateMaybeMessage<::auctionmark::RegionRow>(Arena*);
template<> ::auctionmark::UserAttributeRow* Arena::CreateMaybeMessage<::auctionmark::UserAttributeRow>(Arena*);
template<> ::auctionmark::UserItemRow* Arena::CreateMaybeMessage<::auctionmark::UserItemRow>(Arena*);
template<> ::auctionmark::UserRow* Arena::CreateMaybeMessage<::auctionmark::UserRow>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace auctionmark {

enum Tables : int {
  REGION = 0,
  GLOBAL_ATTRIBUTE_GROUP = 1,
  GLOBAL_ATTRIBUTE_VALUE = 2,
  CATEGORY = 3,
  USER = 4,
  USER_ATTRIBUTE = 5,
  USER_WATCH = 6,
  ITEM = 7,
  ITEM_BID = 8,
  ITEM_FEEDBACK = 9,
  ITEM_ATTRIBUTE = 10,
  ITEM_IMAGE = 11,
  ITEM_COMMENT = 12,
  ITEM_MAX_BID = 13,
  ITEM_PURCHASE = 14,
  USER_ITEM = 15
};
bool Tables_IsValid(int value);
constexpr Tables Tables_MIN = REGION;
constexpr Tables Tables_MAX = USER_ITEM;
constexpr int Tables_ARRAYSIZE = Tables_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tables_descriptor();
template<typename T>
inline const std::string& Tables_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tables>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tables_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tables_descriptor(), enum_t_value);
}
inline bool Tables_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tables* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tables>(
    Tables_descriptor(), name, value);
}
// ===================================================================

class RegionRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.RegionRow) */ {
 public:
  inline RegionRow() : RegionRow(nullptr) {}
  ~RegionRow() override;
  explicit PROTOBUF_CONSTEXPR RegionRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRow(const RegionRow& from);
  RegionRow(RegionRow&& from) noexcept
    : RegionRow() {
    *this = ::std::move(from);
  }

  inline RegionRow& operator=(const RegionRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRow& operator=(RegionRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRow* internal_default_instance() {
    return reinterpret_cast<const RegionRow*>(
               &_RegionRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegionRow& a, RegionRow& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRow& from) {
    RegionRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.RegionRow";
  }
  protected:
  explicit RegionRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRNameFieldNumber = 2,
    kRIdFieldNumber = 1,
  };
  // required string r_name = 2;
  bool has_r_name() const;
  private:
  bool _internal_has_r_name() const;
  public:
  void clear_r_name();
  const std::string& r_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_r_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_r_name();
  PROTOBUF_NODISCARD std::string* release_r_name();
  void set_allocated_r_name(std::string* r_name);
  private:
  const std::string& _internal_r_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_r_name(const std::string& value);
  std::string* _internal_mutable_r_name();
  public:

  // required uint32 r_id = 1;
  bool has_r_id() const;
  private:
  bool _internal_has_r_id() const;
  public:
  void clear_r_id();
  uint32_t r_id() const;
  void set_r_id(uint32_t value);
  private:
  uint32_t _internal_r_id() const;
  void _internal_set_r_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.RegionRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r_name_;
    uint32_t r_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class GlobalAttributeGroupRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.GlobalAttributeGroupRow) */ {
 public:
  inline GlobalAttributeGroupRow() : GlobalAttributeGroupRow(nullptr) {}
  ~GlobalAttributeGroupRow() override;
  explicit PROTOBUF_CONSTEXPR GlobalAttributeGroupRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalAttributeGroupRow(const GlobalAttributeGroupRow& from);
  GlobalAttributeGroupRow(GlobalAttributeGroupRow&& from) noexcept
    : GlobalAttributeGroupRow() {
    *this = ::std::move(from);
  }

  inline GlobalAttributeGroupRow& operator=(const GlobalAttributeGroupRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalAttributeGroupRow& operator=(GlobalAttributeGroupRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalAttributeGroupRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalAttributeGroupRow* internal_default_instance() {
    return reinterpret_cast<const GlobalAttributeGroupRow*>(
               &_GlobalAttributeGroupRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GlobalAttributeGroupRow& a, GlobalAttributeGroupRow& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalAttributeGroupRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalAttributeGroupRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalAttributeGroupRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalAttributeGroupRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalAttributeGroupRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalAttributeGroupRow& from) {
    GlobalAttributeGroupRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalAttributeGroupRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.GlobalAttributeGroupRow";
  }
  protected:
  explicit GlobalAttributeGroupRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGagNameFieldNumber = 3,
    kGagIdFieldNumber = 1,
    kGagCIdFieldNumber = 2,
  };
  // required string gag_name = 3;
  bool has_gag_name() const;
  private:
  bool _internal_has_gag_name() const;
  public:
  void clear_gag_name();
  const std::string& gag_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gag_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gag_name();
  PROTOBUF_NODISCARD std::string* release_gag_name();
  void set_allocated_gag_name(std::string* gag_name);
  private:
  const std::string& _internal_gag_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gag_name(const std::string& value);
  std::string* _internal_mutable_gag_name();
  public:

  // required uint32 gag_id = 1;
  bool has_gag_id() const;
  private:
  bool _internal_has_gag_id() const;
  public:
  void clear_gag_id();
  uint32_t gag_id() const;
  void set_gag_id(uint32_t value);
  private:
  uint32_t _internal_gag_id() const;
  void _internal_set_gag_id(uint32_t value);
  public:

  // required uint32 gag_c_id = 2;
  bool has_gag_c_id() const;
  private:
  bool _internal_has_gag_c_id() const;
  public:
  void clear_gag_c_id();
  uint32_t gag_c_id() const;
  void set_gag_c_id(uint32_t value);
  private:
  uint32_t _internal_gag_c_id() const;
  void _internal_set_gag_c_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.GlobalAttributeGroupRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gag_name_;
    uint32_t gag_id_;
    uint32_t gag_c_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class GlobalAttributeValueRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.GlobalAttributeValueRow) */ {
 public:
  inline GlobalAttributeValueRow() : GlobalAttributeValueRow(nullptr) {}
  ~GlobalAttributeValueRow() override;
  explicit PROTOBUF_CONSTEXPR GlobalAttributeValueRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalAttributeValueRow(const GlobalAttributeValueRow& from);
  GlobalAttributeValueRow(GlobalAttributeValueRow&& from) noexcept
    : GlobalAttributeValueRow() {
    *this = ::std::move(from);
  }

  inline GlobalAttributeValueRow& operator=(const GlobalAttributeValueRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalAttributeValueRow& operator=(GlobalAttributeValueRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalAttributeValueRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalAttributeValueRow* internal_default_instance() {
    return reinterpret_cast<const GlobalAttributeValueRow*>(
               &_GlobalAttributeValueRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GlobalAttributeValueRow& a, GlobalAttributeValueRow& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalAttributeValueRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalAttributeValueRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalAttributeValueRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalAttributeValueRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalAttributeValueRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalAttributeValueRow& from) {
    GlobalAttributeValueRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalAttributeValueRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.GlobalAttributeValueRow";
  }
  protected:
  explicit GlobalAttributeValueRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGavNameFieldNumber = 3,
    kGavIdFieldNumber = 1,
    kGavGagIdFieldNumber = 2,
  };
  // required string gav_name = 3;
  bool has_gav_name() const;
  private:
  bool _internal_has_gav_name() const;
  public:
  void clear_gav_name();
  const std::string& gav_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gav_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gav_name();
  PROTOBUF_NODISCARD std::string* release_gav_name();
  void set_allocated_gav_name(std::string* gav_name);
  private:
  const std::string& _internal_gav_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gav_name(const std::string& value);
  std::string* _internal_mutable_gav_name();
  public:

  // required uint32 gav_id = 1;
  bool has_gav_id() const;
  private:
  bool _internal_has_gav_id() const;
  public:
  void clear_gav_id();
  uint32_t gav_id() const;
  void set_gav_id(uint32_t value);
  private:
  uint32_t _internal_gav_id() const;
  void _internal_set_gav_id(uint32_t value);
  public:

  // required uint32 gav_gag_id = 2;
  bool has_gav_gag_id() const;
  private:
  bool _internal_has_gav_gag_id() const;
  public:
  void clear_gav_gag_id();
  uint32_t gav_gag_id() const;
  void set_gav_gag_id(uint32_t value);
  private:
  uint32_t _internal_gav_gag_id() const;
  void _internal_set_gav_gag_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.GlobalAttributeValueRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gav_name_;
    uint32_t gav_id_;
    uint32_t gav_gag_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class CategoryRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.CategoryRow) */ {
 public:
  inline CategoryRow() : CategoryRow(nullptr) {}
  ~CategoryRow() override;
  explicit PROTOBUF_CONSTEXPR CategoryRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CategoryRow(const CategoryRow& from);
  CategoryRow(CategoryRow&& from) noexcept
    : CategoryRow() {
    *this = ::std::move(from);
  }

  inline CategoryRow& operator=(const CategoryRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline CategoryRow& operator=(CategoryRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CategoryRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const CategoryRow* internal_default_instance() {
    return reinterpret_cast<const CategoryRow*>(
               &_CategoryRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CategoryRow& a, CategoryRow& b) {
    a.Swap(&b);
  }
  inline void Swap(CategoryRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CategoryRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CategoryRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CategoryRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CategoryRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CategoryRow& from) {
    CategoryRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CategoryRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.CategoryRow";
  }
  protected:
  explicit CategoryRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCNameFieldNumber = 2,
    kCIdFieldNumber = 1,
    kCParentIdFieldNumber = 3,
  };
  // required string c_name = 2;
  bool has_c_name() const;
  private:
  bool _internal_has_c_name() const;
  public:
  void clear_c_name();
  const std::string& c_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c_name();
  PROTOBUF_NODISCARD std::string* release_c_name();
  void set_allocated_c_name(std::string* c_name);
  private:
  const std::string& _internal_c_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c_name(const std::string& value);
  std::string* _internal_mutable_c_name();
  public:

  // required uint32 c_id = 1;
  bool has_c_id() const;
  private:
  bool _internal_has_c_id() const;
  public:
  void clear_c_id();
  uint32_t c_id() const;
  void set_c_id(uint32_t value);
  private:
  uint32_t _internal_c_id() const;
  void _internal_set_c_id(uint32_t value);
  public:

  // required uint32 c_parent_id = 3;
  bool has_c_parent_id() const;
  private:
  bool _internal_has_c_parent_id() const;
  public:
  void clear_c_parent_id();
  uint32_t c_parent_id() const;
  void set_c_parent_id(uint32_t value);
  private:
  uint32_t _internal_c_parent_id() const;
  void _internal_set_c_parent_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.CategoryRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_name_;
    uint32_t c_id_;
    uint32_t c_parent_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class UserRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.UserRow) */ {
 public:
  inline UserRow() : UserRow(nullptr) {}
  ~UserRow() override;
  explicit PROTOBUF_CONSTEXPR UserRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRow(const UserRow& from);
  UserRow(UserRow&& from) noexcept
    : UserRow() {
    *this = ::std::move(from);
  }

  inline UserRow& operator=(const UserRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRow& operator=(UserRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRow* internal_default_instance() {
    return reinterpret_cast<const UserRow*>(
               &_UserRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserRow& a, UserRow& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRow& from) {
    UserRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.UserRow";
  }
  protected:
  explicit UserRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUSattr0FieldNumber = 6,
    kUSattr1FieldNumber = 7,
    kUSattr2FieldNumber = 8,
    kUSattr3FieldNumber = 9,
    kUSattr4FieldNumber = 10,
    kUSattr5FieldNumber = 11,
    kUSattr6FieldNumber = 12,
    kUSattr7FieldNumber = 13,
    kUIdFieldNumber = 1,
    kURatingFieldNumber = 2,
    kUBalanceFieldNumber = 3,
    kUCreatedFieldNumber = 4,
    kURIdFieldNumber = 5,
  };
  // required string u_sattr0 = 6;
  bool has_u_sattr0() const;
  private:
  bool _internal_has_u_sattr0() const;
  public:
  void clear_u_sattr0();
  const std::string& u_sattr0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr0();
  PROTOBUF_NODISCARD std::string* release_u_sattr0();
  void set_allocated_u_sattr0(std::string* u_sattr0);
  private:
  const std::string& _internal_u_sattr0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr0(const std::string& value);
  std::string* _internal_mutable_u_sattr0();
  public:

  // required string u_sattr1 = 7;
  bool has_u_sattr1() const;
  private:
  bool _internal_has_u_sattr1() const;
  public:
  void clear_u_sattr1();
  const std::string& u_sattr1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr1();
  PROTOBUF_NODISCARD std::string* release_u_sattr1();
  void set_allocated_u_sattr1(std::string* u_sattr1);
  private:
  const std::string& _internal_u_sattr1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr1(const std::string& value);
  std::string* _internal_mutable_u_sattr1();
  public:

  // required string u_sattr2 = 8;
  bool has_u_sattr2() const;
  private:
  bool _internal_has_u_sattr2() const;
  public:
  void clear_u_sattr2();
  const std::string& u_sattr2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr2();
  PROTOBUF_NODISCARD std::string* release_u_sattr2();
  void set_allocated_u_sattr2(std::string* u_sattr2);
  private:
  const std::string& _internal_u_sattr2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr2(const std::string& value);
  std::string* _internal_mutable_u_sattr2();
  public:

  // required string u_sattr3 = 9;
  bool has_u_sattr3() const;
  private:
  bool _internal_has_u_sattr3() const;
  public:
  void clear_u_sattr3();
  const std::string& u_sattr3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr3();
  PROTOBUF_NODISCARD std::string* release_u_sattr3();
  void set_allocated_u_sattr3(std::string* u_sattr3);
  private:
  const std::string& _internal_u_sattr3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr3(const std::string& value);
  std::string* _internal_mutable_u_sattr3();
  public:

  // required string u_sattr4 = 10;
  bool has_u_sattr4() const;
  private:
  bool _internal_has_u_sattr4() const;
  public:
  void clear_u_sattr4();
  const std::string& u_sattr4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr4();
  PROTOBUF_NODISCARD std::string* release_u_sattr4();
  void set_allocated_u_sattr4(std::string* u_sattr4);
  private:
  const std::string& _internal_u_sattr4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr4(const std::string& value);
  std::string* _internal_mutable_u_sattr4();
  public:

  // required string u_sattr5 = 11;
  bool has_u_sattr5() const;
  private:
  bool _internal_has_u_sattr5() const;
  public:
  void clear_u_sattr5();
  const std::string& u_sattr5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr5();
  PROTOBUF_NODISCARD std::string* release_u_sattr5();
  void set_allocated_u_sattr5(std::string* u_sattr5);
  private:
  const std::string& _internal_u_sattr5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr5(const std::string& value);
  std::string* _internal_mutable_u_sattr5();
  public:

  // required string u_sattr6 = 12;
  bool has_u_sattr6() const;
  private:
  bool _internal_has_u_sattr6() const;
  public:
  void clear_u_sattr6();
  const std::string& u_sattr6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr6();
  PROTOBUF_NODISCARD std::string* release_u_sattr6();
  void set_allocated_u_sattr6(std::string* u_sattr6);
  private:
  const std::string& _internal_u_sattr6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr6(const std::string& value);
  std::string* _internal_mutable_u_sattr6();
  public:

  // required string u_sattr7 = 13;
  bool has_u_sattr7() const;
  private:
  bool _internal_has_u_sattr7() const;
  public:
  void clear_u_sattr7();
  const std::string& u_sattr7() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u_sattr7(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u_sattr7();
  PROTOBUF_NODISCARD std::string* release_u_sattr7();
  void set_allocated_u_sattr7(std::string* u_sattr7);
  private:
  const std::string& _internal_u_sattr7() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u_sattr7(const std::string& value);
  std::string* _internal_mutable_u_sattr7();
  public:

  // required uint32 u_id = 1;
  bool has_u_id() const;
  private:
  bool _internal_has_u_id() const;
  public:
  void clear_u_id();
  uint32_t u_id() const;
  void set_u_id(uint32_t value);
  private:
  uint32_t _internal_u_id() const;
  void _internal_set_u_id(uint32_t value);
  public:

  // required uint32 u_rating = 2;
  bool has_u_rating() const;
  private:
  bool _internal_has_u_rating() const;
  public:
  void clear_u_rating();
  uint32_t u_rating() const;
  void set_u_rating(uint32_t value);
  private:
  uint32_t _internal_u_rating() const;
  void _internal_set_u_rating(uint32_t value);
  public:

  // required double u_balance = 3;
  bool has_u_balance() const;
  private:
  bool _internal_has_u_balance() const;
  public:
  void clear_u_balance();
  double u_balance() const;
  void set_u_balance(double value);
  private:
  double _internal_u_balance() const;
  void _internal_set_u_balance(double value);
  public:

  // required uint32 u_created = 4;
  bool has_u_created() const;
  private:
  bool _internal_has_u_created() const;
  public:
  void clear_u_created();
  uint32_t u_created() const;
  void set_u_created(uint32_t value);
  private:
  uint32_t _internal_u_created() const;
  void _internal_set_u_created(uint32_t value);
  public:

  // required uint32 u_r_id = 5;
  bool has_u_r_id() const;
  private:
  bool _internal_has_u_r_id() const;
  public:
  void clear_u_r_id();
  uint32_t u_r_id() const;
  void set_u_r_id(uint32_t value);
  private:
  uint32_t _internal_u_r_id() const;
  void _internal_set_u_r_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.UserRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr0_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr3_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr4_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr5_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr6_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_sattr7_;
    uint32_t u_id_;
    uint32_t u_rating_;
    double u_balance_;
    uint32_t u_created_;
    uint32_t u_r_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class UserAttributeRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.UserAttributeRow) */ {
 public:
  inline UserAttributeRow() : UserAttributeRow(nullptr) {}
  ~UserAttributeRow() override;
  explicit PROTOBUF_CONSTEXPR UserAttributeRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAttributeRow(const UserAttributeRow& from);
  UserAttributeRow(UserAttributeRow&& from) noexcept
    : UserAttributeRow() {
    *this = ::std::move(from);
  }

  inline UserAttributeRow& operator=(const UserAttributeRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAttributeRow& operator=(UserAttributeRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAttributeRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAttributeRow* internal_default_instance() {
    return reinterpret_cast<const UserAttributeRow*>(
               &_UserAttributeRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserAttributeRow& a, UserAttributeRow& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAttributeRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAttributeRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAttributeRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAttributeRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAttributeRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAttributeRow& from) {
    UserAttributeRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAttributeRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.UserAttributeRow";
  }
  protected:
  explicit UserAttributeRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUaNameFieldNumber = 3,
    kUaValueFieldNumber = 4,
    kUaIdFieldNumber = 1,
    kUaUIdFieldNumber = 2,
    kUCreatedFieldNumber = 5,
  };
  // required string ua_name = 3;
  bool has_ua_name() const;
  private:
  bool _internal_has_ua_name() const;
  public:
  void clear_ua_name();
  const std::string& ua_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ua_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ua_name();
  PROTOBUF_NODISCARD std::string* release_ua_name();
  void set_allocated_ua_name(std::string* ua_name);
  private:
  const std::string& _internal_ua_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ua_name(const std::string& value);
  std::string* _internal_mutable_ua_name();
  public:

  // required string ua_value = 4;
  bool has_ua_value() const;
  private:
  bool _internal_has_ua_value() const;
  public:
  void clear_ua_value();
  const std::string& ua_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ua_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ua_value();
  PROTOBUF_NODISCARD std::string* release_ua_value();
  void set_allocated_ua_value(std::string* ua_value);
  private:
  const std::string& _internal_ua_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ua_value(const std::string& value);
  std::string* _internal_mutable_ua_value();
  public:

  // required uint32 ua_id = 1;
  bool has_ua_id() const;
  private:
  bool _internal_has_ua_id() const;
  public:
  void clear_ua_id();
  uint32_t ua_id() const;
  void set_ua_id(uint32_t value);
  private:
  uint32_t _internal_ua_id() const;
  void _internal_set_ua_id(uint32_t value);
  public:

  // required uint32 ua_u_id = 2;
  bool has_ua_u_id() const;
  private:
  bool _internal_has_ua_u_id() const;
  public:
  void clear_ua_u_id();
  uint32_t ua_u_id() const;
  void set_ua_u_id(uint32_t value);
  private:
  uint32_t _internal_ua_u_id() const;
  void _internal_set_ua_u_id(uint32_t value);
  public:

  // required uint32 u_created = 5;
  bool has_u_created() const;
  private:
  bool _internal_has_u_created() const;
  public:
  void clear_u_created();
  uint32_t u_created() const;
  void set_u_created(uint32_t value);
  private:
  uint32_t _internal_u_created() const;
  void _internal_set_u_created(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.UserAttributeRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ua_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ua_value_;
    uint32_t ua_id_;
    uint32_t ua_u_id_;
    uint32_t u_created_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemRow) */ {
 public:
  inline ItemRow() : ItemRow(nullptr) {}
  ~ItemRow() override;
  explicit PROTOBUF_CONSTEXPR ItemRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemRow(const ItemRow& from);
  ItemRow(ItemRow&& from) noexcept
    : ItemRow() {
    *this = ::std::move(from);
  }

  inline ItemRow& operator=(const ItemRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemRow& operator=(ItemRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemRow* internal_default_instance() {
    return reinterpret_cast<const ItemRow*>(
               &_ItemRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ItemRow& a, ItemRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemRow& from) {
    ItemRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemRow";
  }
  protected:
  explicit ItemRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kINameFieldNumber = 4,
    kIDescriptionFieldNumber = 5,
    kIUserAttributesFieldNumber = 6,
    kIIdFieldNumber = 1,
    kIUIdFieldNumber = 2,
    kICIdFieldNumber = 3,
    kINumBidsFieldNumber = 9,
    kIInitialPriceFieldNumber = 7,
    kICurrentPriceFieldNumber = 8,
    kINumImagesFieldNumber = 10,
    kINumGlobalAttrsFieldNumber = 11,
    kIStartDateFieldNumber = 12,
    kIEndDateFieldNumber = 13,
    kIStatusFieldNumber = 14,
  };
  // required string i_name = 4;
  bool has_i_name() const;
  private:
  bool _internal_has_i_name() const;
  public:
  void clear_i_name();
  const std::string& i_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_i_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_i_name();
  PROTOBUF_NODISCARD std::string* release_i_name();
  void set_allocated_i_name(std::string* i_name);
  private:
  const std::string& _internal_i_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_i_name(const std::string& value);
  std::string* _internal_mutable_i_name();
  public:

  // required string i_description = 5;
  bool has_i_description() const;
  private:
  bool _internal_has_i_description() const;
  public:
  void clear_i_description();
  const std::string& i_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_i_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_i_description();
  PROTOBUF_NODISCARD std::string* release_i_description();
  void set_allocated_i_description(std::string* i_description);
  private:
  const std::string& _internal_i_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_i_description(const std::string& value);
  std::string* _internal_mutable_i_description();
  public:

  // required string i_user_attributes = 6;
  bool has_i_user_attributes() const;
  private:
  bool _internal_has_i_user_attributes() const;
  public:
  void clear_i_user_attributes();
  const std::string& i_user_attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_i_user_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_i_user_attributes();
  PROTOBUF_NODISCARD std::string* release_i_user_attributes();
  void set_allocated_i_user_attributes(std::string* i_user_attributes);
  private:
  const std::string& _internal_i_user_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_i_user_attributes(const std::string& value);
  std::string* _internal_mutable_i_user_attributes();
  public:

  // required uint32 i_id = 1;
  bool has_i_id() const;
  private:
  bool _internal_has_i_id() const;
  public:
  void clear_i_id();
  uint32_t i_id() const;
  void set_i_id(uint32_t value);
  private:
  uint32_t _internal_i_id() const;
  void _internal_set_i_id(uint32_t value);
  public:

  // required uint32 i_u_id = 2;
  bool has_i_u_id() const;
  private:
  bool _internal_has_i_u_id() const;
  public:
  void clear_i_u_id();
  uint32_t i_u_id() const;
  void set_i_u_id(uint32_t value);
  private:
  uint32_t _internal_i_u_id() const;
  void _internal_set_i_u_id(uint32_t value);
  public:

  // required uint32 i_c_id = 3;
  bool has_i_c_id() const;
  private:
  bool _internal_has_i_c_id() const;
  public:
  void clear_i_c_id();
  uint32_t i_c_id() const;
  void set_i_c_id(uint32_t value);
  private:
  uint32_t _internal_i_c_id() const;
  void _internal_set_i_c_id(uint32_t value);
  public:

  // required uint32 i_num_bids = 9;
  bool has_i_num_bids() const;
  private:
  bool _internal_has_i_num_bids() const;
  public:
  void clear_i_num_bids();
  uint32_t i_num_bids() const;
  void set_i_num_bids(uint32_t value);
  private:
  uint32_t _internal_i_num_bids() const;
  void _internal_set_i_num_bids(uint32_t value);
  public:

  // required double i_initial_price = 7;
  bool has_i_initial_price() const;
  private:
  bool _internal_has_i_initial_price() const;
  public:
  void clear_i_initial_price();
  double i_initial_price() const;
  void set_i_initial_price(double value);
  private:
  double _internal_i_initial_price() const;
  void _internal_set_i_initial_price(double value);
  public:

  // required double i_current_price = 8;
  bool has_i_current_price() const;
  private:
  bool _internal_has_i_current_price() const;
  public:
  void clear_i_current_price();
  double i_current_price() const;
  void set_i_current_price(double value);
  private:
  double _internal_i_current_price() const;
  void _internal_set_i_current_price(double value);
  public:

  // required uint32 i_num_images = 10;
  bool has_i_num_images() const;
  private:
  bool _internal_has_i_num_images() const;
  public:
  void clear_i_num_images();
  uint32_t i_num_images() const;
  void set_i_num_images(uint32_t value);
  private:
  uint32_t _internal_i_num_images() const;
  void _internal_set_i_num_images(uint32_t value);
  public:

  // required uint32 i_num_global_attrs = 11;
  bool has_i_num_global_attrs() const;
  private:
  bool _internal_has_i_num_global_attrs() const;
  public:
  void clear_i_num_global_attrs();
  uint32_t i_num_global_attrs() const;
  void set_i_num_global_attrs(uint32_t value);
  private:
  uint32_t _internal_i_num_global_attrs() const;
  void _internal_set_i_num_global_attrs(uint32_t value);
  public:

  // required uint32 i_start_date = 12;
  bool has_i_start_date() const;
  private:
  bool _internal_has_i_start_date() const;
  public:
  void clear_i_start_date();
  uint32_t i_start_date() const;
  void set_i_start_date(uint32_t value);
  private:
  uint32_t _internal_i_start_date() const;
  void _internal_set_i_start_date(uint32_t value);
  public:

  // required uint32 i_end_date = 13;
  bool has_i_end_date() const;
  private:
  bool _internal_has_i_end_date() const;
  public:
  void clear_i_end_date();
  uint32_t i_end_date() const;
  void set_i_end_date(uint32_t value);
  private:
  uint32_t _internal_i_end_date() const;
  void _internal_set_i_end_date(uint32_t value);
  public:

  // required uint32 i_status = 14;
  bool has_i_status() const;
  private:
  bool _internal_has_i_status() const;
  public:
  void clear_i_status();
  uint32_t i_status() const;
  void set_i_status(uint32_t value);
  private:
  uint32_t _internal_i_status() const;
  void _internal_set_i_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr i_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr i_description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr i_user_attributes_;
    uint32_t i_id_;
    uint32_t i_u_id_;
    uint32_t i_c_id_;
    uint32_t i_num_bids_;
    double i_initial_price_;
    double i_current_price_;
    uint32_t i_num_images_;
    uint32_t i_num_global_attrs_;
    uint32_t i_start_date_;
    uint32_t i_end_date_;
    uint32_t i_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemImageRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemImageRow) */ {
 public:
  inline ItemImageRow() : ItemImageRow(nullptr) {}
  ~ItemImageRow() override;
  explicit PROTOBUF_CONSTEXPR ItemImageRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemImageRow(const ItemImageRow& from);
  ItemImageRow(ItemImageRow&& from) noexcept
    : ItemImageRow() {
    *this = ::std::move(from);
  }

  inline ItemImageRow& operator=(const ItemImageRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemImageRow& operator=(ItemImageRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemImageRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemImageRow* internal_default_instance() {
    return reinterpret_cast<const ItemImageRow*>(
               &_ItemImageRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ItemImageRow& a, ItemImageRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemImageRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemImageRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemImageRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemImageRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemImageRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemImageRow& from) {
    ItemImageRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemImageRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemImageRow";
  }
  protected:
  explicit ItemImageRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIiPathFieldNumber = 4,
    kIiIdFieldNumber = 1,
    kIiIIdFieldNumber = 2,
    kIiUIdFieldNumber = 3,
  };
  // required string ii_path = 4;
  bool has_ii_path() const;
  private:
  bool _internal_has_ii_path() const;
  public:
  void clear_ii_path();
  const std::string& ii_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ii_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ii_path();
  PROTOBUF_NODISCARD std::string* release_ii_path();
  void set_allocated_ii_path(std::string* ii_path);
  private:
  const std::string& _internal_ii_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ii_path(const std::string& value);
  std::string* _internal_mutable_ii_path();
  public:

  // required uint32 ii_id = 1;
  bool has_ii_id() const;
  private:
  bool _internal_has_ii_id() const;
  public:
  void clear_ii_id();
  uint32_t ii_id() const;
  void set_ii_id(uint32_t value);
  private:
  uint32_t _internal_ii_id() const;
  void _internal_set_ii_id(uint32_t value);
  public:

  // required uint32 ii_i_id = 2;
  bool has_ii_i_id() const;
  private:
  bool _internal_has_ii_i_id() const;
  public:
  void clear_ii_i_id();
  uint32_t ii_i_id() const;
  void set_ii_i_id(uint32_t value);
  private:
  uint32_t _internal_ii_i_id() const;
  void _internal_set_ii_i_id(uint32_t value);
  public:

  // required uint32 ii_u_id = 3;
  bool has_ii_u_id() const;
  private:
  bool _internal_has_ii_u_id() const;
  public:
  void clear_ii_u_id();
  uint32_t ii_u_id() const;
  void set_ii_u_id(uint32_t value);
  private:
  uint32_t _internal_ii_u_id() const;
  void _internal_set_ii_u_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemImageRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ii_path_;
    uint32_t ii_id_;
    uint32_t ii_i_id_;
    uint32_t ii_u_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemCommentRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemCommentRow) */ {
 public:
  inline ItemCommentRow() : ItemCommentRow(nullptr) {}
  ~ItemCommentRow() override;
  explicit PROTOBUF_CONSTEXPR ItemCommentRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemCommentRow(const ItemCommentRow& from);
  ItemCommentRow(ItemCommentRow&& from) noexcept
    : ItemCommentRow() {
    *this = ::std::move(from);
  }

  inline ItemCommentRow& operator=(const ItemCommentRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemCommentRow& operator=(ItemCommentRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemCommentRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemCommentRow* internal_default_instance() {
    return reinterpret_cast<const ItemCommentRow*>(
               &_ItemCommentRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ItemCommentRow& a, ItemCommentRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemCommentRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemCommentRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemCommentRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemCommentRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemCommentRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemCommentRow& from) {
    ItemCommentRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemCommentRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemCommentRow";
  }
  protected:
  explicit ItemCommentRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIcQuestionFieldNumber = 6,
    kIcResponseFieldNumber = 7,
    kIcIdFieldNumber = 1,
    kIcIIdFieldNumber = 2,
    kIcUIdFieldNumber = 3,
    kIcBuyerIdFieldNumber = 4,
    kIcDateFieldNumber = 5,
  };
  // required string ic_question = 6;
  bool has_ic_question() const;
  private:
  bool _internal_has_ic_question() const;
  public:
  void clear_ic_question();
  const std::string& ic_question() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ic_question(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ic_question();
  PROTOBUF_NODISCARD std::string* release_ic_question();
  void set_allocated_ic_question(std::string* ic_question);
  private:
  const std::string& _internal_ic_question() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ic_question(const std::string& value);
  std::string* _internal_mutable_ic_question();
  public:

  // required string ic_response = 7;
  bool has_ic_response() const;
  private:
  bool _internal_has_ic_response() const;
  public:
  void clear_ic_response();
  const std::string& ic_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ic_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ic_response();
  PROTOBUF_NODISCARD std::string* release_ic_response();
  void set_allocated_ic_response(std::string* ic_response);
  private:
  const std::string& _internal_ic_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ic_response(const std::string& value);
  std::string* _internal_mutable_ic_response();
  public:

  // required uint32 ic_id = 1;
  bool has_ic_id() const;
  private:
  bool _internal_has_ic_id() const;
  public:
  void clear_ic_id();
  uint32_t ic_id() const;
  void set_ic_id(uint32_t value);
  private:
  uint32_t _internal_ic_id() const;
  void _internal_set_ic_id(uint32_t value);
  public:

  // required uint32 ic_i_id = 2;
  bool has_ic_i_id() const;
  private:
  bool _internal_has_ic_i_id() const;
  public:
  void clear_ic_i_id();
  uint32_t ic_i_id() const;
  void set_ic_i_id(uint32_t value);
  private:
  uint32_t _internal_ic_i_id() const;
  void _internal_set_ic_i_id(uint32_t value);
  public:

  // required uint32 ic_u_id = 3;
  bool has_ic_u_id() const;
  private:
  bool _internal_has_ic_u_id() const;
  public:
  void clear_ic_u_id();
  uint32_t ic_u_id() const;
  void set_ic_u_id(uint32_t value);
  private:
  uint32_t _internal_ic_u_id() const;
  void _internal_set_ic_u_id(uint32_t value);
  public:

  // required uint32 ic_buyer_id = 4;
  bool has_ic_buyer_id() const;
  private:
  bool _internal_has_ic_buyer_id() const;
  public:
  void clear_ic_buyer_id();
  uint32_t ic_buyer_id() const;
  void set_ic_buyer_id(uint32_t value);
  private:
  uint32_t _internal_ic_buyer_id() const;
  void _internal_set_ic_buyer_id(uint32_t value);
  public:

  // required uint32 ic_date = 5;
  bool has_ic_date() const;
  private:
  bool _internal_has_ic_date() const;
  public:
  void clear_ic_date();
  uint32_t ic_date() const;
  void set_ic_date(uint32_t value);
  private:
  uint32_t _internal_ic_date() const;
  void _internal_set_ic_date(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemCommentRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ic_question_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ic_response_;
    uint32_t ic_id_;
    uint32_t ic_i_id_;
    uint32_t ic_u_id_;
    uint32_t ic_buyer_id_;
    uint32_t ic_date_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemFeedbackRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemFeedbackRow) */ {
 public:
  inline ItemFeedbackRow() : ItemFeedbackRow(nullptr) {}
  ~ItemFeedbackRow() override;
  explicit PROTOBUF_CONSTEXPR ItemFeedbackRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemFeedbackRow(const ItemFeedbackRow& from);
  ItemFeedbackRow(ItemFeedbackRow&& from) noexcept
    : ItemFeedbackRow() {
    *this = ::std::move(from);
  }

  inline ItemFeedbackRow& operator=(const ItemFeedbackRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemFeedbackRow& operator=(ItemFeedbackRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemFeedbackRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemFeedbackRow* internal_default_instance() {
    return reinterpret_cast<const ItemFeedbackRow*>(
               &_ItemFeedbackRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ItemFeedbackRow& a, ItemFeedbackRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemFeedbackRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemFeedbackRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemFeedbackRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemFeedbackRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemFeedbackRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemFeedbackRow& from) {
    ItemFeedbackRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemFeedbackRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemFeedbackRow";
  }
  protected:
  explicit ItemFeedbackRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfCommentFieldNumber = 7,
    kIfIdFieldNumber = 1,
    kIfIIdFieldNumber = 2,
    kIfUIdFieldNumber = 3,
    kIfBuyerIdFieldNumber = 4,
    kIfRatingFieldNumber = 5,
    kIfDateFieldNumber = 6,
  };
  // required string if_comment = 7;
  bool has_if_comment() const;
  private:
  bool _internal_has_if_comment() const;
  public:
  void clear_if_comment();
  const std::string& if_comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_if_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_if_comment();
  PROTOBUF_NODISCARD std::string* release_if_comment();
  void set_allocated_if_comment(std::string* if_comment);
  private:
  const std::string& _internal_if_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_if_comment(const std::string& value);
  std::string* _internal_mutable_if_comment();
  public:

  // required uint32 if_id = 1;
  bool has_if_id() const;
  private:
  bool _internal_has_if_id() const;
  public:
  void clear_if_id();
  uint32_t if_id() const;
  void set_if_id(uint32_t value);
  private:
  uint32_t _internal_if_id() const;
  void _internal_set_if_id(uint32_t value);
  public:

  // required uint32 if_i_id = 2;
  bool has_if_i_id() const;
  private:
  bool _internal_has_if_i_id() const;
  public:
  void clear_if_i_id();
  uint32_t if_i_id() const;
  void set_if_i_id(uint32_t value);
  private:
  uint32_t _internal_if_i_id() const;
  void _internal_set_if_i_id(uint32_t value);
  public:

  // required uint32 if_u_id = 3;
  bool has_if_u_id() const;
  private:
  bool _internal_has_if_u_id() const;
  public:
  void clear_if_u_id();
  uint32_t if_u_id() const;
  void set_if_u_id(uint32_t value);
  private:
  uint32_t _internal_if_u_id() const;
  void _internal_set_if_u_id(uint32_t value);
  public:

  // required uint32 if_buyer_id = 4;
  bool has_if_buyer_id() const;
  private:
  bool _internal_has_if_buyer_id() const;
  public:
  void clear_if_buyer_id();
  uint32_t if_buyer_id() const;
  void set_if_buyer_id(uint32_t value);
  private:
  uint32_t _internal_if_buyer_id() const;
  void _internal_set_if_buyer_id(uint32_t value);
  public:

  // required uint32 if_rating = 5;
  bool has_if_rating() const;
  private:
  bool _internal_has_if_rating() const;
  public:
  void clear_if_rating();
  uint32_t if_rating() const;
  void set_if_rating(uint32_t value);
  private:
  uint32_t _internal_if_rating() const;
  void _internal_set_if_rating(uint32_t value);
  public:

  // required uint32 if_date = 6;
  bool has_if_date() const;
  private:
  bool _internal_has_if_date() const;
  public:
  void clear_if_date();
  uint32_t if_date() const;
  void set_if_date(uint32_t value);
  private:
  uint32_t _internal_if_date() const;
  void _internal_set_if_date(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemFeedbackRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_comment_;
    uint32_t if_id_;
    uint32_t if_i_id_;
    uint32_t if_u_id_;
    uint32_t if_buyer_id_;
    uint32_t if_rating_;
    uint32_t if_date_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemBidRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemBidRow) */ {
 public:
  inline ItemBidRow() : ItemBidRow(nullptr) {}
  ~ItemBidRow() override;
  explicit PROTOBUF_CONSTEXPR ItemBidRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemBidRow(const ItemBidRow& from);
  ItemBidRow(ItemBidRow&& from) noexcept
    : ItemBidRow() {
    *this = ::std::move(from);
  }

  inline ItemBidRow& operator=(const ItemBidRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemBidRow& operator=(ItemBidRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemBidRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemBidRow* internal_default_instance() {
    return reinterpret_cast<const ItemBidRow*>(
               &_ItemBidRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ItemBidRow& a, ItemBidRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemBidRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemBidRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemBidRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemBidRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemBidRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemBidRow& from) {
    ItemBidRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemBidRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemBidRow";
  }
  protected:
  explicit ItemBidRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIbIdFieldNumber = 1,
    kIbIIdFieldNumber = 2,
    kIbUIdFieldNumber = 3,
    kIbBuyerIdFieldNumber = 4,
    kIbBidFieldNumber = 5,
    kIbMaxBidFieldNumber = 6,
    kIbCreatedFieldNumber = 7,
    kIbUpdatedFieldNumber = 8,
  };
  // required uint32 ib_id = 1;
  bool has_ib_id() const;
  private:
  bool _internal_has_ib_id() const;
  public:
  void clear_ib_id();
  uint32_t ib_id() const;
  void set_ib_id(uint32_t value);
  private:
  uint32_t _internal_ib_id() const;
  void _internal_set_ib_id(uint32_t value);
  public:

  // required uint32 ib_i_id = 2;
  bool has_ib_i_id() const;
  private:
  bool _internal_has_ib_i_id() const;
  public:
  void clear_ib_i_id();
  uint32_t ib_i_id() const;
  void set_ib_i_id(uint32_t value);
  private:
  uint32_t _internal_ib_i_id() const;
  void _internal_set_ib_i_id(uint32_t value);
  public:

  // required uint32 ib_u_id = 3;
  bool has_ib_u_id() const;
  private:
  bool _internal_has_ib_u_id() const;
  public:
  void clear_ib_u_id();
  uint32_t ib_u_id() const;
  void set_ib_u_id(uint32_t value);
  private:
  uint32_t _internal_ib_u_id() const;
  void _internal_set_ib_u_id(uint32_t value);
  public:

  // required uint32 ib_buyer_id = 4;
  bool has_ib_buyer_id() const;
  private:
  bool _internal_has_ib_buyer_id() const;
  public:
  void clear_ib_buyer_id();
  uint32_t ib_buyer_id() const;
  void set_ib_buyer_id(uint32_t value);
  private:
  uint32_t _internal_ib_buyer_id() const;
  void _internal_set_ib_buyer_id(uint32_t value);
  public:

  // required double ib_bid = 5;
  bool has_ib_bid() const;
  private:
  bool _internal_has_ib_bid() const;
  public:
  void clear_ib_bid();
  double ib_bid() const;
  void set_ib_bid(double value);
  private:
  double _internal_ib_bid() const;
  void _internal_set_ib_bid(double value);
  public:

  // required double ib_max_bid = 6;
  bool has_ib_max_bid() const;
  private:
  bool _internal_has_ib_max_bid() const;
  public:
  void clear_ib_max_bid();
  double ib_max_bid() const;
  void set_ib_max_bid(double value);
  private:
  double _internal_ib_max_bid() const;
  void _internal_set_ib_max_bid(double value);
  public:

  // required uint32 ib_created = 7;
  bool has_ib_created() const;
  private:
  bool _internal_has_ib_created() const;
  public:
  void clear_ib_created();
  uint32_t ib_created() const;
  void set_ib_created(uint32_t value);
  private:
  uint32_t _internal_ib_created() const;
  void _internal_set_ib_created(uint32_t value);
  public:

  // required uint32 ib_updated = 8;
  bool has_ib_updated() const;
  private:
  bool _internal_has_ib_updated() const;
  public:
  void clear_ib_updated();
  uint32_t ib_updated() const;
  void set_ib_updated(uint32_t value);
  private:
  uint32_t _internal_ib_updated() const;
  void _internal_set_ib_updated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemBidRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t ib_id_;
    uint32_t ib_i_id_;
    uint32_t ib_u_id_;
    uint32_t ib_buyer_id_;
    double ib_bid_;
    double ib_max_bid_;
    uint32_t ib_created_;
    uint32_t ib_updated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemMaxBidRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemMaxBidRow) */ {
 public:
  inline ItemMaxBidRow() : ItemMaxBidRow(nullptr) {}
  ~ItemMaxBidRow() override;
  explicit PROTOBUF_CONSTEXPR ItemMaxBidRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemMaxBidRow(const ItemMaxBidRow& from);
  ItemMaxBidRow(ItemMaxBidRow&& from) noexcept
    : ItemMaxBidRow() {
    *this = ::std::move(from);
  }

  inline ItemMaxBidRow& operator=(const ItemMaxBidRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemMaxBidRow& operator=(ItemMaxBidRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemMaxBidRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemMaxBidRow* internal_default_instance() {
    return reinterpret_cast<const ItemMaxBidRow*>(
               &_ItemMaxBidRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ItemMaxBidRow& a, ItemMaxBidRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemMaxBidRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemMaxBidRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemMaxBidRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemMaxBidRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemMaxBidRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemMaxBidRow& from) {
    ItemMaxBidRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemMaxBidRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemMaxBidRow";
  }
  protected:
  explicit ItemMaxBidRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImbIIdFieldNumber = 1,
    kImbUIdFieldNumber = 2,
    kImbIbIdFieldNumber = 3,
    kImbIbIIdFieldNumber = 4,
    kImbIbUIdFieldNumber = 5,
    kImbCreatedFieldNumber = 6,
    kImbUpdatedFieldNumber = 7,
  };
  // required uint32 imb_i_id = 1;
  bool has_imb_i_id() const;
  private:
  bool _internal_has_imb_i_id() const;
  public:
  void clear_imb_i_id();
  uint32_t imb_i_id() const;
  void set_imb_i_id(uint32_t value);
  private:
  uint32_t _internal_imb_i_id() const;
  void _internal_set_imb_i_id(uint32_t value);
  public:

  // required uint32 imb_u_id = 2;
  bool has_imb_u_id() const;
  private:
  bool _internal_has_imb_u_id() const;
  public:
  void clear_imb_u_id();
  uint32_t imb_u_id() const;
  void set_imb_u_id(uint32_t value);
  private:
  uint32_t _internal_imb_u_id() const;
  void _internal_set_imb_u_id(uint32_t value);
  public:

  // required uint32 imb_ib_id = 3;
  bool has_imb_ib_id() const;
  private:
  bool _internal_has_imb_ib_id() const;
  public:
  void clear_imb_ib_id();
  uint32_t imb_ib_id() const;
  void set_imb_ib_id(uint32_t value);
  private:
  uint32_t _internal_imb_ib_id() const;
  void _internal_set_imb_ib_id(uint32_t value);
  public:

  // required uint32 imb_ib_i_id = 4;
  bool has_imb_ib_i_id() const;
  private:
  bool _internal_has_imb_ib_i_id() const;
  public:
  void clear_imb_ib_i_id();
  uint32_t imb_ib_i_id() const;
  void set_imb_ib_i_id(uint32_t value);
  private:
  uint32_t _internal_imb_ib_i_id() const;
  void _internal_set_imb_ib_i_id(uint32_t value);
  public:

  // required uint32 imb_ib_u_id = 5;
  bool has_imb_ib_u_id() const;
  private:
  bool _internal_has_imb_ib_u_id() const;
  public:
  void clear_imb_ib_u_id();
  uint32_t imb_ib_u_id() const;
  void set_imb_ib_u_id(uint32_t value);
  private:
  uint32_t _internal_imb_ib_u_id() const;
  void _internal_set_imb_ib_u_id(uint32_t value);
  public:

  // required uint32 imb_created = 6;
  bool has_imb_created() const;
  private:
  bool _internal_has_imb_created() const;
  public:
  void clear_imb_created();
  uint32_t imb_created() const;
  void set_imb_created(uint32_t value);
  private:
  uint32_t _internal_imb_created() const;
  void _internal_set_imb_created(uint32_t value);
  public:

  // required uint32 imb_updated = 7;
  bool has_imb_updated() const;
  private:
  bool _internal_has_imb_updated() const;
  public:
  void clear_imb_updated();
  uint32_t imb_updated() const;
  void set_imb_updated(uint32_t value);
  private:
  uint32_t _internal_imb_updated() const;
  void _internal_set_imb_updated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemMaxBidRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t imb_i_id_;
    uint32_t imb_u_id_;
    uint32_t imb_ib_id_;
    uint32_t imb_ib_i_id_;
    uint32_t imb_ib_u_id_;
    uint32_t imb_created_;
    uint32_t imb_updated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class ItemPurchaseRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.ItemPurchaseRow) */ {
 public:
  inline ItemPurchaseRow() : ItemPurchaseRow(nullptr) {}
  ~ItemPurchaseRow() override;
  explicit PROTOBUF_CONSTEXPR ItemPurchaseRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemPurchaseRow(const ItemPurchaseRow& from);
  ItemPurchaseRow(ItemPurchaseRow&& from) noexcept
    : ItemPurchaseRow() {
    *this = ::std::move(from);
  }

  inline ItemPurchaseRow& operator=(const ItemPurchaseRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemPurchaseRow& operator=(ItemPurchaseRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemPurchaseRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemPurchaseRow* internal_default_instance() {
    return reinterpret_cast<const ItemPurchaseRow*>(
               &_ItemPurchaseRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ItemPurchaseRow& a, ItemPurchaseRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemPurchaseRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemPurchaseRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemPurchaseRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemPurchaseRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemPurchaseRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemPurchaseRow& from) {
    ItemPurchaseRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemPurchaseRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.ItemPurchaseRow";
  }
  protected:
  explicit ItemPurchaseRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpIdFieldNumber = 1,
    kIpIbIdFieldNumber = 2,
    kIpIIdFieldNumber = 3,
    kIpUIdFieldNumber = 4,
    kIpDateFieldNumber = 5,
  };
  // required uint32 ip_id = 1;
  bool has_ip_id() const;
  private:
  bool _internal_has_ip_id() const;
  public:
  void clear_ip_id();
  uint32_t ip_id() const;
  void set_ip_id(uint32_t value);
  private:
  uint32_t _internal_ip_id() const;
  void _internal_set_ip_id(uint32_t value);
  public:

  // required uint32 ip_ib_id = 2;
  bool has_ip_ib_id() const;
  private:
  bool _internal_has_ip_ib_id() const;
  public:
  void clear_ip_ib_id();
  uint32_t ip_ib_id() const;
  void set_ip_ib_id(uint32_t value);
  private:
  uint32_t _internal_ip_ib_id() const;
  void _internal_set_ip_ib_id(uint32_t value);
  public:

  // required uint32 ip_i_id = 3;
  bool has_ip_i_id() const;
  private:
  bool _internal_has_ip_i_id() const;
  public:
  void clear_ip_i_id();
  uint32_t ip_i_id() const;
  void set_ip_i_id(uint32_t value);
  private:
  uint32_t _internal_ip_i_id() const;
  void _internal_set_ip_i_id(uint32_t value);
  public:

  // required uint32 ip_u_id = 4;
  bool has_ip_u_id() const;
  private:
  bool _internal_has_ip_u_id() const;
  public:
  void clear_ip_u_id();
  uint32_t ip_u_id() const;
  void set_ip_u_id(uint32_t value);
  private:
  uint32_t _internal_ip_u_id() const;
  void _internal_set_ip_u_id(uint32_t value);
  public:

  // required uint32 ip_date = 5;
  bool has_ip_date() const;
  private:
  bool _internal_has_ip_date() const;
  public:
  void clear_ip_date();
  uint32_t ip_date() const;
  void set_ip_date(uint32_t value);
  private:
  uint32_t _internal_ip_date() const;
  void _internal_set_ip_date(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.ItemPurchaseRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t ip_id_;
    uint32_t ip_ib_id_;
    uint32_t ip_i_id_;
    uint32_t ip_u_id_;
    uint32_t ip_date_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// -------------------------------------------------------------------

class UserItemRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auctionmark.UserItemRow) */ {
 public:
  inline UserItemRow() : UserItemRow(nullptr) {}
  ~UserItemRow() override;
  explicit PROTOBUF_CONSTEXPR UserItemRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserItemRow(const UserItemRow& from);
  UserItemRow(UserItemRow&& from) noexcept
    : UserItemRow() {
    *this = ::std::move(from);
  }

  inline UserItemRow& operator=(const UserItemRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserItemRow& operator=(UserItemRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserItemRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserItemRow* internal_default_instance() {
    return reinterpret_cast<const UserItemRow*>(
               &_UserItemRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserItemRow& a, UserItemRow& b) {
    a.Swap(&b);
  }
  inline void Swap(UserItemRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserItemRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserItemRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserItemRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserItemRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserItemRow& from) {
    UserItemRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserItemRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auctionmark.UserItemRow";
  }
  protected:
  explicit UserItemRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUiUIdFieldNumber = 1,
    kUiIIdFieldNumber = 2,
    kUiSellerIdFieldNumber = 3,
    kUiCreatedFieldNumber = 4,
  };
  // required uint32 ui_u_id = 1;
  bool has_ui_u_id() const;
  private:
  bool _internal_has_ui_u_id() const;
  public:
  void clear_ui_u_id();
  uint32_t ui_u_id() const;
  void set_ui_u_id(uint32_t value);
  private:
  uint32_t _internal_ui_u_id() const;
  void _internal_set_ui_u_id(uint32_t value);
  public:

  // required uint32 ui_i_id = 2;
  bool has_ui_i_id() const;
  private:
  bool _internal_has_ui_i_id() const;
  public:
  void clear_ui_i_id();
  uint32_t ui_i_id() const;
  void set_ui_i_id(uint32_t value);
  private:
  uint32_t _internal_ui_i_id() const;
  void _internal_set_ui_i_id(uint32_t value);
  public:

  // required uint32 ui_seller_id = 3;
  bool has_ui_seller_id() const;
  private:
  bool _internal_has_ui_seller_id() const;
  public:
  void clear_ui_seller_id();
  uint32_t ui_seller_id() const;
  void set_ui_seller_id(uint32_t value);
  private:
  uint32_t _internal_ui_seller_id() const;
  void _internal_set_ui_seller_id(uint32_t value);
  public:

  // required uint32 ui_created = 4;
  bool has_ui_created() const;
  private:
  bool _internal_has_ui_created() const;
  public:
  void clear_ui_created();
  uint32_t ui_created() const;
  void set_ui_created(uint32_t value);
  private:
  uint32_t _internal_ui_created() const;
  void _internal_set_ui_created(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:auctionmark.UserItemRow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t ui_u_id_;
    uint32_t ui_i_id_;
    uint32_t ui_seller_id_;
    uint32_t ui_created_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auctionmark_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegionRow

// required uint32 r_id = 1;
inline bool RegionRow::_internal_has_r_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionRow::has_r_id() const {
  return _internal_has_r_id();
}
inline void RegionRow::clear_r_id() {
  _impl_.r_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RegionRow::_internal_r_id() const {
  return _impl_.r_id_;
}
inline uint32_t RegionRow::r_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.RegionRow.r_id)
  return _internal_r_id();
}
inline void RegionRow::_internal_set_r_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.r_id_ = value;
}
inline void RegionRow::set_r_id(uint32_t value) {
  _internal_set_r_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.RegionRow.r_id)
}

// required string r_name = 2;
inline bool RegionRow::_internal_has_r_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionRow::has_r_name() const {
  return _internal_has_r_name();
}
inline void RegionRow::clear_r_name() {
  _impl_.r_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionRow::r_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.RegionRow.r_name)
  return _internal_r_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionRow::set_r_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.r_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.RegionRow.r_name)
}
inline std::string* RegionRow::mutable_r_name() {
  std::string* _s = _internal_mutable_r_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.RegionRow.r_name)
  return _s;
}
inline const std::string& RegionRow::_internal_r_name() const {
  return _impl_.r_name_.Get();
}
inline void RegionRow::_internal_set_r_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.r_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionRow::_internal_mutable_r_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.r_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionRow::release_r_name() {
  // @@protoc_insertion_point(field_release:auctionmark.RegionRow.r_name)
  if (!_internal_has_r_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.r_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.r_name_.IsDefault()) {
    _impl_.r_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegionRow::set_allocated_r_name(std::string* r_name) {
  if (r_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.r_name_.SetAllocated(r_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.r_name_.IsDefault()) {
    _impl_.r_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.RegionRow.r_name)
}

// -------------------------------------------------------------------

// GlobalAttributeGroupRow

// required uint32 gag_id = 1;
inline bool GlobalAttributeGroupRow::_internal_has_gag_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlobalAttributeGroupRow::has_gag_id() const {
  return _internal_has_gag_id();
}
inline void GlobalAttributeGroupRow::clear_gag_id() {
  _impl_.gag_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GlobalAttributeGroupRow::_internal_gag_id() const {
  return _impl_.gag_id_;
}
inline uint32_t GlobalAttributeGroupRow::gag_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeGroupRow.gag_id)
  return _internal_gag_id();
}
inline void GlobalAttributeGroupRow::_internal_set_gag_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gag_id_ = value;
}
inline void GlobalAttributeGroupRow::set_gag_id(uint32_t value) {
  _internal_set_gag_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeGroupRow.gag_id)
}

// required uint32 gag_c_id = 2;
inline bool GlobalAttributeGroupRow::_internal_has_gag_c_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlobalAttributeGroupRow::has_gag_c_id() const {
  return _internal_has_gag_c_id();
}
inline void GlobalAttributeGroupRow::clear_gag_c_id() {
  _impl_.gag_c_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GlobalAttributeGroupRow::_internal_gag_c_id() const {
  return _impl_.gag_c_id_;
}
inline uint32_t GlobalAttributeGroupRow::gag_c_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeGroupRow.gag_c_id)
  return _internal_gag_c_id();
}
inline void GlobalAttributeGroupRow::_internal_set_gag_c_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gag_c_id_ = value;
}
inline void GlobalAttributeGroupRow::set_gag_c_id(uint32_t value) {
  _internal_set_gag_c_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeGroupRow.gag_c_id)
}

// required string gag_name = 3;
inline bool GlobalAttributeGroupRow::_internal_has_gag_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalAttributeGroupRow::has_gag_name() const {
  return _internal_has_gag_name();
}
inline void GlobalAttributeGroupRow::clear_gag_name() {
  _impl_.gag_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GlobalAttributeGroupRow::gag_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeGroupRow.gag_name)
  return _internal_gag_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GlobalAttributeGroupRow::set_gag_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gag_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeGroupRow.gag_name)
}
inline std::string* GlobalAttributeGroupRow::mutable_gag_name() {
  std::string* _s = _internal_mutable_gag_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.GlobalAttributeGroupRow.gag_name)
  return _s;
}
inline const std::string& GlobalAttributeGroupRow::_internal_gag_name() const {
  return _impl_.gag_name_.Get();
}
inline void GlobalAttributeGroupRow::_internal_set_gag_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gag_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GlobalAttributeGroupRow::_internal_mutable_gag_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gag_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GlobalAttributeGroupRow::release_gag_name() {
  // @@protoc_insertion_point(field_release:auctionmark.GlobalAttributeGroupRow.gag_name)
  if (!_internal_has_gag_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gag_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gag_name_.IsDefault()) {
    _impl_.gag_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GlobalAttributeGroupRow::set_allocated_gag_name(std::string* gag_name) {
  if (gag_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gag_name_.SetAllocated(gag_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gag_name_.IsDefault()) {
    _impl_.gag_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.GlobalAttributeGroupRow.gag_name)
}

// -------------------------------------------------------------------

// GlobalAttributeValueRow

// required uint32 gav_id = 1;
inline bool GlobalAttributeValueRow::_internal_has_gav_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlobalAttributeValueRow::has_gav_id() const {
  return _internal_has_gav_id();
}
inline void GlobalAttributeValueRow::clear_gav_id() {
  _impl_.gav_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GlobalAttributeValueRow::_internal_gav_id() const {
  return _impl_.gav_id_;
}
inline uint32_t GlobalAttributeValueRow::gav_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeValueRow.gav_id)
  return _internal_gav_id();
}
inline void GlobalAttributeValueRow::_internal_set_gav_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gav_id_ = value;
}
inline void GlobalAttributeValueRow::set_gav_id(uint32_t value) {
  _internal_set_gav_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeValueRow.gav_id)
}

// required uint32 gav_gag_id = 2;
inline bool GlobalAttributeValueRow::_internal_has_gav_gag_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlobalAttributeValueRow::has_gav_gag_id() const {
  return _internal_has_gav_gag_id();
}
inline void GlobalAttributeValueRow::clear_gav_gag_id() {
  _impl_.gav_gag_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GlobalAttributeValueRow::_internal_gav_gag_id() const {
  return _impl_.gav_gag_id_;
}
inline uint32_t GlobalAttributeValueRow::gav_gag_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeValueRow.gav_gag_id)
  return _internal_gav_gag_id();
}
inline void GlobalAttributeValueRow::_internal_set_gav_gag_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gav_gag_id_ = value;
}
inline void GlobalAttributeValueRow::set_gav_gag_id(uint32_t value) {
  _internal_set_gav_gag_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeValueRow.gav_gag_id)
}

// required string gav_name = 3;
inline bool GlobalAttributeValueRow::_internal_has_gav_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalAttributeValueRow::has_gav_name() const {
  return _internal_has_gav_name();
}
inline void GlobalAttributeValueRow::clear_gav_name() {
  _impl_.gav_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GlobalAttributeValueRow::gav_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.GlobalAttributeValueRow.gav_name)
  return _internal_gav_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GlobalAttributeValueRow::set_gav_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gav_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.GlobalAttributeValueRow.gav_name)
}
inline std::string* GlobalAttributeValueRow::mutable_gav_name() {
  std::string* _s = _internal_mutable_gav_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.GlobalAttributeValueRow.gav_name)
  return _s;
}
inline const std::string& GlobalAttributeValueRow::_internal_gav_name() const {
  return _impl_.gav_name_.Get();
}
inline void GlobalAttributeValueRow::_internal_set_gav_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gav_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GlobalAttributeValueRow::_internal_mutable_gav_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gav_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GlobalAttributeValueRow::release_gav_name() {
  // @@protoc_insertion_point(field_release:auctionmark.GlobalAttributeValueRow.gav_name)
  if (!_internal_has_gav_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gav_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gav_name_.IsDefault()) {
    _impl_.gav_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GlobalAttributeValueRow::set_allocated_gav_name(std::string* gav_name) {
  if (gav_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gav_name_.SetAllocated(gav_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gav_name_.IsDefault()) {
    _impl_.gav_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.GlobalAttributeValueRow.gav_name)
}

// -------------------------------------------------------------------

// CategoryRow

// required uint32 c_id = 1;
inline bool CategoryRow::_internal_has_c_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CategoryRow::has_c_id() const {
  return _internal_has_c_id();
}
inline void CategoryRow::clear_c_id() {
  _impl_.c_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CategoryRow::_internal_c_id() const {
  return _impl_.c_id_;
}
inline uint32_t CategoryRow::c_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.CategoryRow.c_id)
  return _internal_c_id();
}
inline void CategoryRow::_internal_set_c_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.c_id_ = value;
}
inline void CategoryRow::set_c_id(uint32_t value) {
  _internal_set_c_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.CategoryRow.c_id)
}

// required string c_name = 2;
inline bool CategoryRow::_internal_has_c_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CategoryRow::has_c_name() const {
  return _internal_has_c_name();
}
inline void CategoryRow::clear_c_name() {
  _impl_.c_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CategoryRow::c_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.CategoryRow.c_name)
  return _internal_c_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CategoryRow::set_c_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.c_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.CategoryRow.c_name)
}
inline std::string* CategoryRow::mutable_c_name() {
  std::string* _s = _internal_mutable_c_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.CategoryRow.c_name)
  return _s;
}
inline const std::string& CategoryRow::_internal_c_name() const {
  return _impl_.c_name_.Get();
}
inline void CategoryRow::_internal_set_c_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.c_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CategoryRow::_internal_mutable_c_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.c_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CategoryRow::release_c_name() {
  // @@protoc_insertion_point(field_release:auctionmark.CategoryRow.c_name)
  if (!_internal_has_c_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.c_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.c_name_.IsDefault()) {
    _impl_.c_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CategoryRow::set_allocated_c_name(std::string* c_name) {
  if (c_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.c_name_.SetAllocated(c_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.c_name_.IsDefault()) {
    _impl_.c_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.CategoryRow.c_name)
}

// required uint32 c_parent_id = 3;
inline bool CategoryRow::_internal_has_c_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CategoryRow::has_c_parent_id() const {
  return _internal_has_c_parent_id();
}
inline void CategoryRow::clear_c_parent_id() {
  _impl_.c_parent_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CategoryRow::_internal_c_parent_id() const {
  return _impl_.c_parent_id_;
}
inline uint32_t CategoryRow::c_parent_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.CategoryRow.c_parent_id)
  return _internal_c_parent_id();
}
inline void CategoryRow::_internal_set_c_parent_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.c_parent_id_ = value;
}
inline void CategoryRow::set_c_parent_id(uint32_t value) {
  _internal_set_c_parent_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.CategoryRow.c_parent_id)
}

// -------------------------------------------------------------------

// UserRow

// required uint32 u_id = 1;
inline bool UserRow::_internal_has_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserRow::has_u_id() const {
  return _internal_has_u_id();
}
inline void UserRow::clear_u_id() {
  _impl_.u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t UserRow::_internal_u_id() const {
  return _impl_.u_id_;
}
inline uint32_t UserRow::u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_id)
  return _internal_u_id();
}
inline void UserRow::_internal_set_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.u_id_ = value;
}
inline void UserRow::set_u_id(uint32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_id)
}

// required uint32 u_rating = 2;
inline bool UserRow::_internal_has_u_rating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserRow::has_u_rating() const {
  return _internal_has_u_rating();
}
inline void UserRow::clear_u_rating() {
  _impl_.u_rating_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t UserRow::_internal_u_rating() const {
  return _impl_.u_rating_;
}
inline uint32_t UserRow::u_rating() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_rating)
  return _internal_u_rating();
}
inline void UserRow::_internal_set_u_rating(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.u_rating_ = value;
}
inline void UserRow::set_u_rating(uint32_t value) {
  _internal_set_u_rating(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_rating)
}

// required double u_balance = 3;
inline bool UserRow::_internal_has_u_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserRow::has_u_balance() const {
  return _internal_has_u_balance();
}
inline void UserRow::clear_u_balance() {
  _impl_.u_balance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double UserRow::_internal_u_balance() const {
  return _impl_.u_balance_;
}
inline double UserRow::u_balance() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_balance)
  return _internal_u_balance();
}
inline void UserRow::_internal_set_u_balance(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.u_balance_ = value;
}
inline void UserRow::set_u_balance(double value) {
  _internal_set_u_balance(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_balance)
}

// required uint32 u_created = 4;
inline bool UserRow::_internal_has_u_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserRow::has_u_created() const {
  return _internal_has_u_created();
}
inline void UserRow::clear_u_created() {
  _impl_.u_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t UserRow::_internal_u_created() const {
  return _impl_.u_created_;
}
inline uint32_t UserRow::u_created() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_created)
  return _internal_u_created();
}
inline void UserRow::_internal_set_u_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.u_created_ = value;
}
inline void UserRow::set_u_created(uint32_t value) {
  _internal_set_u_created(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_created)
}

// required uint32 u_r_id = 5;
inline bool UserRow::_internal_has_u_r_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UserRow::has_u_r_id() const {
  return _internal_has_u_r_id();
}
inline void UserRow::clear_u_r_id() {
  _impl_.u_r_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t UserRow::_internal_u_r_id() const {
  return _impl_.u_r_id_;
}
inline uint32_t UserRow::u_r_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_r_id)
  return _internal_u_r_id();
}
inline void UserRow::_internal_set_u_r_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.u_r_id_ = value;
}
inline void UserRow::set_u_r_id(uint32_t value) {
  _internal_set_u_r_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_r_id)
}

// required string u_sattr0 = 6;
inline bool UserRow::_internal_has_u_sattr0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr0() const {
  return _internal_has_u_sattr0();
}
inline void UserRow::clear_u_sattr0() {
  _impl_.u_sattr0_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserRow::u_sattr0() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr0)
  return _internal_u_sattr0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr0(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.u_sattr0_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr0)
}
inline std::string* UserRow::mutable_u_sattr0() {
  std::string* _s = _internal_mutable_u_sattr0();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr0)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr0() const {
  return _impl_.u_sattr0_.Get();
}
inline void UserRow::_internal_set_u_sattr0(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u_sattr0_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.u_sattr0_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr0() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr0)
  if (!_internal_has_u_sattr0()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.u_sattr0_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr0_.IsDefault()) {
    _impl_.u_sattr0_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr0(std::string* u_sattr0) {
  if (u_sattr0 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.u_sattr0_.SetAllocated(u_sattr0, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr0_.IsDefault()) {
    _impl_.u_sattr0_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr0)
}

// required string u_sattr1 = 7;
inline bool UserRow::_internal_has_u_sattr1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr1() const {
  return _internal_has_u_sattr1();
}
inline void UserRow::clear_u_sattr1() {
  _impl_.u_sattr1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserRow::u_sattr1() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr1)
  return _internal_u_sattr1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.u_sattr1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr1)
}
inline std::string* UserRow::mutable_u_sattr1() {
  std::string* _s = _internal_mutable_u_sattr1();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr1)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr1() const {
  return _impl_.u_sattr1_.Get();
}
inline void UserRow::_internal_set_u_sattr1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.u_sattr1_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.u_sattr1_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr1() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr1)
  if (!_internal_has_u_sattr1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.u_sattr1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr1_.IsDefault()) {
    _impl_.u_sattr1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr1(std::string* u_sattr1) {
  if (u_sattr1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.u_sattr1_.SetAllocated(u_sattr1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr1_.IsDefault()) {
    _impl_.u_sattr1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr1)
}

// required string u_sattr2 = 8;
inline bool UserRow::_internal_has_u_sattr2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr2() const {
  return _internal_has_u_sattr2();
}
inline void UserRow::clear_u_sattr2() {
  _impl_.u_sattr2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserRow::u_sattr2() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr2)
  return _internal_u_sattr2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.u_sattr2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr2)
}
inline std::string* UserRow::mutable_u_sattr2() {
  std::string* _s = _internal_mutable_u_sattr2();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr2)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr2() const {
  return _impl_.u_sattr2_.Get();
}
inline void UserRow::_internal_set_u_sattr2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.u_sattr2_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr2() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.u_sattr2_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr2() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr2)
  if (!_internal_has_u_sattr2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.u_sattr2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr2_.IsDefault()) {
    _impl_.u_sattr2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr2(std::string* u_sattr2) {
  if (u_sattr2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.u_sattr2_.SetAllocated(u_sattr2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr2_.IsDefault()) {
    _impl_.u_sattr2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr2)
}

// required string u_sattr3 = 9;
inline bool UserRow::_internal_has_u_sattr3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr3() const {
  return _internal_has_u_sattr3();
}
inline void UserRow::clear_u_sattr3() {
  _impl_.u_sattr3_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserRow::u_sattr3() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr3)
  return _internal_u_sattr3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr3(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.u_sattr3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr3)
}
inline std::string* UserRow::mutable_u_sattr3() {
  std::string* _s = _internal_mutable_u_sattr3();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr3)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr3() const {
  return _impl_.u_sattr3_.Get();
}
inline void UserRow::_internal_set_u_sattr3(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.u_sattr3_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr3() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.u_sattr3_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr3() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr3)
  if (!_internal_has_u_sattr3()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.u_sattr3_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr3_.IsDefault()) {
    _impl_.u_sattr3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr3(std::string* u_sattr3) {
  if (u_sattr3 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.u_sattr3_.SetAllocated(u_sattr3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr3_.IsDefault()) {
    _impl_.u_sattr3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr3)
}

// required string u_sattr4 = 10;
inline bool UserRow::_internal_has_u_sattr4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr4() const {
  return _internal_has_u_sattr4();
}
inline void UserRow::clear_u_sattr4() {
  _impl_.u_sattr4_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserRow::u_sattr4() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr4)
  return _internal_u_sattr4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr4(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.u_sattr4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr4)
}
inline std::string* UserRow::mutable_u_sattr4() {
  std::string* _s = _internal_mutable_u_sattr4();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr4)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr4() const {
  return _impl_.u_sattr4_.Get();
}
inline void UserRow::_internal_set_u_sattr4(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.u_sattr4_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr4() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.u_sattr4_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr4() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr4)
  if (!_internal_has_u_sattr4()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.u_sattr4_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr4_.IsDefault()) {
    _impl_.u_sattr4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr4(std::string* u_sattr4) {
  if (u_sattr4 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.u_sattr4_.SetAllocated(u_sattr4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr4_.IsDefault()) {
    _impl_.u_sattr4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr4)
}

// required string u_sattr5 = 11;
inline bool UserRow::_internal_has_u_sattr5() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr5() const {
  return _internal_has_u_sattr5();
}
inline void UserRow::clear_u_sattr5() {
  _impl_.u_sattr5_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserRow::u_sattr5() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr5)
  return _internal_u_sattr5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr5(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.u_sattr5_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr5)
}
inline std::string* UserRow::mutable_u_sattr5() {
  std::string* _s = _internal_mutable_u_sattr5();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr5)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr5() const {
  return _impl_.u_sattr5_.Get();
}
inline void UserRow::_internal_set_u_sattr5(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.u_sattr5_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr5() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.u_sattr5_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr5() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr5)
  if (!_internal_has_u_sattr5()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.u_sattr5_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr5_.IsDefault()) {
    _impl_.u_sattr5_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr5(std::string* u_sattr5) {
  if (u_sattr5 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.u_sattr5_.SetAllocated(u_sattr5, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr5_.IsDefault()) {
    _impl_.u_sattr5_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr5)
}

// required string u_sattr6 = 12;
inline bool UserRow::_internal_has_u_sattr6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr6() const {
  return _internal_has_u_sattr6();
}
inline void UserRow::clear_u_sattr6() {
  _impl_.u_sattr6_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserRow::u_sattr6() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr6)
  return _internal_u_sattr6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr6(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.u_sattr6_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr6)
}
inline std::string* UserRow::mutable_u_sattr6() {
  std::string* _s = _internal_mutable_u_sattr6();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr6)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr6() const {
  return _impl_.u_sattr6_.Get();
}
inline void UserRow::_internal_set_u_sattr6(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.u_sattr6_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr6() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.u_sattr6_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr6() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr6)
  if (!_internal_has_u_sattr6()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.u_sattr6_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr6_.IsDefault()) {
    _impl_.u_sattr6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr6(std::string* u_sattr6) {
  if (u_sattr6 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.u_sattr6_.SetAllocated(u_sattr6, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr6_.IsDefault()) {
    _impl_.u_sattr6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr6)
}

// required string u_sattr7 = 13;
inline bool UserRow::_internal_has_u_sattr7() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserRow::has_u_sattr7() const {
  return _internal_has_u_sattr7();
}
inline void UserRow::clear_u_sattr7() {
  _impl_.u_sattr7_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserRow::u_sattr7() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserRow.u_sattr7)
  return _internal_u_sattr7();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRow::set_u_sattr7(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.u_sattr7_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserRow.u_sattr7)
}
inline std::string* UserRow::mutable_u_sattr7() {
  std::string* _s = _internal_mutable_u_sattr7();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserRow.u_sattr7)
  return _s;
}
inline const std::string& UserRow::_internal_u_sattr7() const {
  return _impl_.u_sattr7_.Get();
}
inline void UserRow::_internal_set_u_sattr7(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.u_sattr7_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRow::_internal_mutable_u_sattr7() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.u_sattr7_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRow::release_u_sattr7() {
  // @@protoc_insertion_point(field_release:auctionmark.UserRow.u_sattr7)
  if (!_internal_has_u_sattr7()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.u_sattr7_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr7_.IsDefault()) {
    _impl_.u_sattr7_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserRow::set_allocated_u_sattr7(std::string* u_sattr7) {
  if (u_sattr7 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.u_sattr7_.SetAllocated(u_sattr7, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.u_sattr7_.IsDefault()) {
    _impl_.u_sattr7_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserRow.u_sattr7)
}

// -------------------------------------------------------------------

// UserAttributeRow

// required uint32 ua_id = 1;
inline bool UserAttributeRow::_internal_has_ua_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserAttributeRow::has_ua_id() const {
  return _internal_has_ua_id();
}
inline void UserAttributeRow::clear_ua_id() {
  _impl_.ua_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserAttributeRow::_internal_ua_id() const {
  return _impl_.ua_id_;
}
inline uint32_t UserAttributeRow::ua_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserAttributeRow.ua_id)
  return _internal_ua_id();
}
inline void UserAttributeRow::_internal_set_ua_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ua_id_ = value;
}
inline void UserAttributeRow::set_ua_id(uint32_t value) {
  _internal_set_ua_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserAttributeRow.ua_id)
}

// required uint32 ua_u_id = 2;
inline bool UserAttributeRow::_internal_has_ua_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserAttributeRow::has_ua_u_id() const {
  return _internal_has_ua_u_id();
}
inline void UserAttributeRow::clear_ua_u_id() {
  _impl_.ua_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserAttributeRow::_internal_ua_u_id() const {
  return _impl_.ua_u_id_;
}
inline uint32_t UserAttributeRow::ua_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserAttributeRow.ua_u_id)
  return _internal_ua_u_id();
}
inline void UserAttributeRow::_internal_set_ua_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ua_u_id_ = value;
}
inline void UserAttributeRow::set_ua_u_id(uint32_t value) {
  _internal_set_ua_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserAttributeRow.ua_u_id)
}

// required string ua_name = 3;
inline bool UserAttributeRow::_internal_has_ua_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserAttributeRow::has_ua_name() const {
  return _internal_has_ua_name();
}
inline void UserAttributeRow::clear_ua_name() {
  _impl_.ua_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserAttributeRow::ua_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserAttributeRow.ua_name)
  return _internal_ua_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAttributeRow::set_ua_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ua_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserAttributeRow.ua_name)
}
inline std::string* UserAttributeRow::mutable_ua_name() {
  std::string* _s = _internal_mutable_ua_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserAttributeRow.ua_name)
  return _s;
}
inline const std::string& UserAttributeRow::_internal_ua_name() const {
  return _impl_.ua_name_.Get();
}
inline void UserAttributeRow::_internal_set_ua_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ua_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAttributeRow::_internal_mutable_ua_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ua_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAttributeRow::release_ua_name() {
  // @@protoc_insertion_point(field_release:auctionmark.UserAttributeRow.ua_name)
  if (!_internal_has_ua_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ua_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ua_name_.IsDefault()) {
    _impl_.ua_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserAttributeRow::set_allocated_ua_name(std::string* ua_name) {
  if (ua_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ua_name_.SetAllocated(ua_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ua_name_.IsDefault()) {
    _impl_.ua_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserAttributeRow.ua_name)
}

// required string ua_value = 4;
inline bool UserAttributeRow::_internal_has_ua_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserAttributeRow::has_ua_value() const {
  return _internal_has_ua_value();
}
inline void UserAttributeRow::clear_ua_value() {
  _impl_.ua_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserAttributeRow::ua_value() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserAttributeRow.ua_value)
  return _internal_ua_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAttributeRow::set_ua_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ua_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.UserAttributeRow.ua_value)
}
inline std::string* UserAttributeRow::mutable_ua_value() {
  std::string* _s = _internal_mutable_ua_value();
  // @@protoc_insertion_point(field_mutable:auctionmark.UserAttributeRow.ua_value)
  return _s;
}
inline const std::string& UserAttributeRow::_internal_ua_value() const {
  return _impl_.ua_value_.Get();
}
inline void UserAttributeRow::_internal_set_ua_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ua_value_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAttributeRow::_internal_mutable_ua_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ua_value_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAttributeRow::release_ua_value() {
  // @@protoc_insertion_point(field_release:auctionmark.UserAttributeRow.ua_value)
  if (!_internal_has_ua_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ua_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ua_value_.IsDefault()) {
    _impl_.ua_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserAttributeRow::set_allocated_ua_value(std::string* ua_value) {
  if (ua_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ua_value_.SetAllocated(ua_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ua_value_.IsDefault()) {
    _impl_.ua_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.UserAttributeRow.ua_value)
}

// required uint32 u_created = 5;
inline bool UserAttributeRow::_internal_has_u_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserAttributeRow::has_u_created() const {
  return _internal_has_u_created();
}
inline void UserAttributeRow::clear_u_created() {
  _impl_.u_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserAttributeRow::_internal_u_created() const {
  return _impl_.u_created_;
}
inline uint32_t UserAttributeRow::u_created() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserAttributeRow.u_created)
  return _internal_u_created();
}
inline void UserAttributeRow::_internal_set_u_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.u_created_ = value;
}
inline void UserAttributeRow::set_u_created(uint32_t value) {
  _internal_set_u_created(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserAttributeRow.u_created)
}

// -------------------------------------------------------------------

// ItemRow

// required uint32 i_id = 1;
inline bool ItemRow::_internal_has_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemRow::has_i_id() const {
  return _internal_has_i_id();
}
inline void ItemRow::clear_i_id() {
  _impl_.i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemRow::_internal_i_id() const {
  return _impl_.i_id_;
}
inline uint32_t ItemRow::i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_id)
  return _internal_i_id();
}
inline void ItemRow::_internal_set_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.i_id_ = value;
}
inline void ItemRow::set_i_id(uint32_t value) {
  _internal_set_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_id)
}

// required uint32 i_u_id = 2;
inline bool ItemRow::_internal_has_i_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemRow::has_i_u_id() const {
  return _internal_has_i_u_id();
}
inline void ItemRow::clear_i_u_id() {
  _impl_.i_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ItemRow::_internal_i_u_id() const {
  return _impl_.i_u_id_;
}
inline uint32_t ItemRow::i_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_u_id)
  return _internal_i_u_id();
}
inline void ItemRow::_internal_set_i_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.i_u_id_ = value;
}
inline void ItemRow::set_i_u_id(uint32_t value) {
  _internal_set_i_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_u_id)
}

// required uint32 i_c_id = 3;
inline bool ItemRow::_internal_has_i_c_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemRow::has_i_c_id() const {
  return _internal_has_i_c_id();
}
inline void ItemRow::clear_i_c_id() {
  _impl_.i_c_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ItemRow::_internal_i_c_id() const {
  return _impl_.i_c_id_;
}
inline uint32_t ItemRow::i_c_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_c_id)
  return _internal_i_c_id();
}
inline void ItemRow::_internal_set_i_c_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.i_c_id_ = value;
}
inline void ItemRow::set_i_c_id(uint32_t value) {
  _internal_set_i_c_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_c_id)
}

// required string i_name = 4;
inline bool ItemRow::_internal_has_i_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemRow::has_i_name() const {
  return _internal_has_i_name();
}
inline void ItemRow::clear_i_name() {
  _impl_.i_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemRow::i_name() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_name)
  return _internal_i_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemRow::set_i_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.i_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_name)
}
inline std::string* ItemRow::mutable_i_name() {
  std::string* _s = _internal_mutable_i_name();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemRow.i_name)
  return _s;
}
inline const std::string& ItemRow::_internal_i_name() const {
  return _impl_.i_name_.Get();
}
inline void ItemRow::_internal_set_i_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.i_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemRow::_internal_mutable_i_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.i_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemRow::release_i_name() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemRow.i_name)
  if (!_internal_has_i_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.i_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_name_.IsDefault()) {
    _impl_.i_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemRow::set_allocated_i_name(std::string* i_name) {
  if (i_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.i_name_.SetAllocated(i_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_name_.IsDefault()) {
    _impl_.i_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemRow.i_name)
}

// required string i_description = 5;
inline bool ItemRow::_internal_has_i_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemRow::has_i_description() const {
  return _internal_has_i_description();
}
inline void ItemRow::clear_i_description() {
  _impl_.i_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ItemRow::i_description() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_description)
  return _internal_i_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemRow::set_i_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.i_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_description)
}
inline std::string* ItemRow::mutable_i_description() {
  std::string* _s = _internal_mutable_i_description();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemRow.i_description)
  return _s;
}
inline const std::string& ItemRow::_internal_i_description() const {
  return _impl_.i_description_.Get();
}
inline void ItemRow::_internal_set_i_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.i_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemRow::_internal_mutable_i_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.i_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemRow::release_i_description() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemRow.i_description)
  if (!_internal_has_i_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.i_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_description_.IsDefault()) {
    _impl_.i_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemRow::set_allocated_i_description(std::string* i_description) {
  if (i_description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.i_description_.SetAllocated(i_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_description_.IsDefault()) {
    _impl_.i_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemRow.i_description)
}

// required string i_user_attributes = 6;
inline bool ItemRow::_internal_has_i_user_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemRow::has_i_user_attributes() const {
  return _internal_has_i_user_attributes();
}
inline void ItemRow::clear_i_user_attributes() {
  _impl_.i_user_attributes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ItemRow::i_user_attributes() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_user_attributes)
  return _internal_i_user_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemRow::set_i_user_attributes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.i_user_attributes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_user_attributes)
}
inline std::string* ItemRow::mutable_i_user_attributes() {
  std::string* _s = _internal_mutable_i_user_attributes();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemRow.i_user_attributes)
  return _s;
}
inline const std::string& ItemRow::_internal_i_user_attributes() const {
  return _impl_.i_user_attributes_.Get();
}
inline void ItemRow::_internal_set_i_user_attributes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.i_user_attributes_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemRow::_internal_mutable_i_user_attributes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.i_user_attributes_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemRow::release_i_user_attributes() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemRow.i_user_attributes)
  if (!_internal_has_i_user_attributes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.i_user_attributes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_user_attributes_.IsDefault()) {
    _impl_.i_user_attributes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemRow::set_allocated_i_user_attributes(std::string* i_user_attributes) {
  if (i_user_attributes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.i_user_attributes_.SetAllocated(i_user_attributes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.i_user_attributes_.IsDefault()) {
    _impl_.i_user_attributes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemRow.i_user_attributes)
}

// required double i_initial_price = 7;
inline bool ItemRow::_internal_has_i_initial_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ItemRow::has_i_initial_price() const {
  return _internal_has_i_initial_price();
}
inline void ItemRow::clear_i_initial_price() {
  _impl_.i_initial_price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double ItemRow::_internal_i_initial_price() const {
  return _impl_.i_initial_price_;
}
inline double ItemRow::i_initial_price() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_initial_price)
  return _internal_i_initial_price();
}
inline void ItemRow::_internal_set_i_initial_price(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.i_initial_price_ = value;
}
inline void ItemRow::set_i_initial_price(double value) {
  _internal_set_i_initial_price(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_initial_price)
}

// required double i_current_price = 8;
inline bool ItemRow::_internal_has_i_current_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ItemRow::has_i_current_price() const {
  return _internal_has_i_current_price();
}
inline void ItemRow::clear_i_current_price() {
  _impl_.i_current_price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double ItemRow::_internal_i_current_price() const {
  return _impl_.i_current_price_;
}
inline double ItemRow::i_current_price() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_current_price)
  return _internal_i_current_price();
}
inline void ItemRow::_internal_set_i_current_price(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.i_current_price_ = value;
}
inline void ItemRow::set_i_current_price(double value) {
  _internal_set_i_current_price(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_current_price)
}

// required uint32 i_num_bids = 9;
inline bool ItemRow::_internal_has_i_num_bids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemRow::has_i_num_bids() const {
  return _internal_has_i_num_bids();
}
inline void ItemRow::clear_i_num_bids() {
  _impl_.i_num_bids_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ItemRow::_internal_i_num_bids() const {
  return _impl_.i_num_bids_;
}
inline uint32_t ItemRow::i_num_bids() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_num_bids)
  return _internal_i_num_bids();
}
inline void ItemRow::_internal_set_i_num_bids(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.i_num_bids_ = value;
}
inline void ItemRow::set_i_num_bids(uint32_t value) {
  _internal_set_i_num_bids(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_num_bids)
}

// required uint32 i_num_images = 10;
inline bool ItemRow::_internal_has_i_num_images() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ItemRow::has_i_num_images() const {
  return _internal_has_i_num_images();
}
inline void ItemRow::clear_i_num_images() {
  _impl_.i_num_images_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t ItemRow::_internal_i_num_images() const {
  return _impl_.i_num_images_;
}
inline uint32_t ItemRow::i_num_images() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_num_images)
  return _internal_i_num_images();
}
inline void ItemRow::_internal_set_i_num_images(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.i_num_images_ = value;
}
inline void ItemRow::set_i_num_images(uint32_t value) {
  _internal_set_i_num_images(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_num_images)
}

// required uint32 i_num_global_attrs = 11;
inline bool ItemRow::_internal_has_i_num_global_attrs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ItemRow::has_i_num_global_attrs() const {
  return _internal_has_i_num_global_attrs();
}
inline void ItemRow::clear_i_num_global_attrs() {
  _impl_.i_num_global_attrs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t ItemRow::_internal_i_num_global_attrs() const {
  return _impl_.i_num_global_attrs_;
}
inline uint32_t ItemRow::i_num_global_attrs() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_num_global_attrs)
  return _internal_i_num_global_attrs();
}
inline void ItemRow::_internal_set_i_num_global_attrs(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.i_num_global_attrs_ = value;
}
inline void ItemRow::set_i_num_global_attrs(uint32_t value) {
  _internal_set_i_num_global_attrs(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_num_global_attrs)
}

// required uint32 i_start_date = 12;
inline bool ItemRow::_internal_has_i_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ItemRow::has_i_start_date() const {
  return _internal_has_i_start_date();
}
inline void ItemRow::clear_i_start_date() {
  _impl_.i_start_date_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t ItemRow::_internal_i_start_date() const {
  return _impl_.i_start_date_;
}
inline uint32_t ItemRow::i_start_date() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_start_date)
  return _internal_i_start_date();
}
inline void ItemRow::_internal_set_i_start_date(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.i_start_date_ = value;
}
inline void ItemRow::set_i_start_date(uint32_t value) {
  _internal_set_i_start_date(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_start_date)
}

// required uint32 i_end_date = 13;
inline bool ItemRow::_internal_has_i_end_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ItemRow::has_i_end_date() const {
  return _internal_has_i_end_date();
}
inline void ItemRow::clear_i_end_date() {
  _impl_.i_end_date_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t ItemRow::_internal_i_end_date() const {
  return _impl_.i_end_date_;
}
inline uint32_t ItemRow::i_end_date() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_end_date)
  return _internal_i_end_date();
}
inline void ItemRow::_internal_set_i_end_date(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.i_end_date_ = value;
}
inline void ItemRow::set_i_end_date(uint32_t value) {
  _internal_set_i_end_date(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_end_date)
}

// required uint32 i_status = 14;
inline bool ItemRow::_internal_has_i_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ItemRow::has_i_status() const {
  return _internal_has_i_status();
}
inline void ItemRow::clear_i_status() {
  _impl_.i_status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t ItemRow::_internal_i_status() const {
  return _impl_.i_status_;
}
inline uint32_t ItemRow::i_status() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemRow.i_status)
  return _internal_i_status();
}
inline void ItemRow::_internal_set_i_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.i_status_ = value;
}
inline void ItemRow::set_i_status(uint32_t value) {
  _internal_set_i_status(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemRow.i_status)
}

// -------------------------------------------------------------------

// ItemImageRow

// required uint32 ii_id = 1;
inline bool ItemImageRow::_internal_has_ii_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemImageRow::has_ii_id() const {
  return _internal_has_ii_id();
}
inline void ItemImageRow::clear_ii_id() {
  _impl_.ii_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemImageRow::_internal_ii_id() const {
  return _impl_.ii_id_;
}
inline uint32_t ItemImageRow::ii_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemImageRow.ii_id)
  return _internal_ii_id();
}
inline void ItemImageRow::_internal_set_ii_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ii_id_ = value;
}
inline void ItemImageRow::set_ii_id(uint32_t value) {
  _internal_set_ii_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemImageRow.ii_id)
}

// required uint32 ii_i_id = 2;
inline bool ItemImageRow::_internal_has_ii_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemImageRow::has_ii_i_id() const {
  return _internal_has_ii_i_id();
}
inline void ItemImageRow::clear_ii_i_id() {
  _impl_.ii_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemImageRow::_internal_ii_i_id() const {
  return _impl_.ii_i_id_;
}
inline uint32_t ItemImageRow::ii_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemImageRow.ii_i_id)
  return _internal_ii_i_id();
}
inline void ItemImageRow::_internal_set_ii_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ii_i_id_ = value;
}
inline void ItemImageRow::set_ii_i_id(uint32_t value) {
  _internal_set_ii_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemImageRow.ii_i_id)
}

// required uint32 ii_u_id = 3;
inline bool ItemImageRow::_internal_has_ii_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemImageRow::has_ii_u_id() const {
  return _internal_has_ii_u_id();
}
inline void ItemImageRow::clear_ii_u_id() {
  _impl_.ii_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemImageRow::_internal_ii_u_id() const {
  return _impl_.ii_u_id_;
}
inline uint32_t ItemImageRow::ii_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemImageRow.ii_u_id)
  return _internal_ii_u_id();
}
inline void ItemImageRow::_internal_set_ii_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ii_u_id_ = value;
}
inline void ItemImageRow::set_ii_u_id(uint32_t value) {
  _internal_set_ii_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemImageRow.ii_u_id)
}

// required string ii_path = 4;
inline bool ItemImageRow::_internal_has_ii_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemImageRow::has_ii_path() const {
  return _internal_has_ii_path();
}
inline void ItemImageRow::clear_ii_path() {
  _impl_.ii_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemImageRow::ii_path() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemImageRow.ii_path)
  return _internal_ii_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemImageRow::set_ii_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ii_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemImageRow.ii_path)
}
inline std::string* ItemImageRow::mutable_ii_path() {
  std::string* _s = _internal_mutable_ii_path();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemImageRow.ii_path)
  return _s;
}
inline const std::string& ItemImageRow::_internal_ii_path() const {
  return _impl_.ii_path_.Get();
}
inline void ItemImageRow::_internal_set_ii_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ii_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemImageRow::_internal_mutable_ii_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ii_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemImageRow::release_ii_path() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemImageRow.ii_path)
  if (!_internal_has_ii_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ii_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ii_path_.IsDefault()) {
    _impl_.ii_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemImageRow::set_allocated_ii_path(std::string* ii_path) {
  if (ii_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ii_path_.SetAllocated(ii_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ii_path_.IsDefault()) {
    _impl_.ii_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemImageRow.ii_path)
}

// -------------------------------------------------------------------

// ItemCommentRow

// required uint32 ic_id = 1;
inline bool ItemCommentRow::_internal_has_ic_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_id() const {
  return _internal_has_ic_id();
}
inline void ItemCommentRow::clear_ic_id() {
  _impl_.ic_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemCommentRow::_internal_ic_id() const {
  return _impl_.ic_id_;
}
inline uint32_t ItemCommentRow::ic_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_id)
  return _internal_ic_id();
}
inline void ItemCommentRow::_internal_set_ic_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ic_id_ = value;
}
inline void ItemCommentRow::set_ic_id(uint32_t value) {
  _internal_set_ic_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_id)
}

// required uint32 ic_i_id = 2;
inline bool ItemCommentRow::_internal_has_ic_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_i_id() const {
  return _internal_has_ic_i_id();
}
inline void ItemCommentRow::clear_ic_i_id() {
  _impl_.ic_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemCommentRow::_internal_ic_i_id() const {
  return _impl_.ic_i_id_;
}
inline uint32_t ItemCommentRow::ic_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_i_id)
  return _internal_ic_i_id();
}
inline void ItemCommentRow::_internal_set_ic_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ic_i_id_ = value;
}
inline void ItemCommentRow::set_ic_i_id(uint32_t value) {
  _internal_set_ic_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_i_id)
}

// required uint32 ic_u_id = 3;
inline bool ItemCommentRow::_internal_has_ic_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_u_id() const {
  return _internal_has_ic_u_id();
}
inline void ItemCommentRow::clear_ic_u_id() {
  _impl_.ic_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ItemCommentRow::_internal_ic_u_id() const {
  return _impl_.ic_u_id_;
}
inline uint32_t ItemCommentRow::ic_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_u_id)
  return _internal_ic_u_id();
}
inline void ItemCommentRow::_internal_set_ic_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ic_u_id_ = value;
}
inline void ItemCommentRow::set_ic_u_id(uint32_t value) {
  _internal_set_ic_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_u_id)
}

// required uint32 ic_buyer_id = 4;
inline bool ItemCommentRow::_internal_has_ic_buyer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_buyer_id() const {
  return _internal_has_ic_buyer_id();
}
inline void ItemCommentRow::clear_ic_buyer_id() {
  _impl_.ic_buyer_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ItemCommentRow::_internal_ic_buyer_id() const {
  return _impl_.ic_buyer_id_;
}
inline uint32_t ItemCommentRow::ic_buyer_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_buyer_id)
  return _internal_ic_buyer_id();
}
inline void ItemCommentRow::_internal_set_ic_buyer_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ic_buyer_id_ = value;
}
inline void ItemCommentRow::set_ic_buyer_id(uint32_t value) {
  _internal_set_ic_buyer_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_buyer_id)
}

// required uint32 ic_date = 5;
inline bool ItemCommentRow::_internal_has_ic_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_date() const {
  return _internal_has_ic_date();
}
inline void ItemCommentRow::clear_ic_date() {
  _impl_.ic_date_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ItemCommentRow::_internal_ic_date() const {
  return _impl_.ic_date_;
}
inline uint32_t ItemCommentRow::ic_date() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_date)
  return _internal_ic_date();
}
inline void ItemCommentRow::_internal_set_ic_date(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ic_date_ = value;
}
inline void ItemCommentRow::set_ic_date(uint32_t value) {
  _internal_set_ic_date(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_date)
}

// required string ic_question = 6;
inline bool ItemCommentRow::_internal_has_ic_question() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_question() const {
  return _internal_has_ic_question();
}
inline void ItemCommentRow::clear_ic_question() {
  _impl_.ic_question_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemCommentRow::ic_question() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_question)
  return _internal_ic_question();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemCommentRow::set_ic_question(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ic_question_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_question)
}
inline std::string* ItemCommentRow::mutable_ic_question() {
  std::string* _s = _internal_mutable_ic_question();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemCommentRow.ic_question)
  return _s;
}
inline const std::string& ItemCommentRow::_internal_ic_question() const {
  return _impl_.ic_question_.Get();
}
inline void ItemCommentRow::_internal_set_ic_question(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ic_question_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemCommentRow::_internal_mutable_ic_question() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ic_question_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemCommentRow::release_ic_question() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemCommentRow.ic_question)
  if (!_internal_has_ic_question()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ic_question_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ic_question_.IsDefault()) {
    _impl_.ic_question_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemCommentRow::set_allocated_ic_question(std::string* ic_question) {
  if (ic_question != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ic_question_.SetAllocated(ic_question, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ic_question_.IsDefault()) {
    _impl_.ic_question_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemCommentRow.ic_question)
}

// required string ic_response = 7;
inline bool ItemCommentRow::_internal_has_ic_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemCommentRow::has_ic_response() const {
  return _internal_has_ic_response();
}
inline void ItemCommentRow::clear_ic_response() {
  _impl_.ic_response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ItemCommentRow::ic_response() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemCommentRow.ic_response)
  return _internal_ic_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemCommentRow::set_ic_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ic_response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemCommentRow.ic_response)
}
inline std::string* ItemCommentRow::mutable_ic_response() {
  std::string* _s = _internal_mutable_ic_response();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemCommentRow.ic_response)
  return _s;
}
inline const std::string& ItemCommentRow::_internal_ic_response() const {
  return _impl_.ic_response_.Get();
}
inline void ItemCommentRow::_internal_set_ic_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ic_response_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemCommentRow::_internal_mutable_ic_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ic_response_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemCommentRow::release_ic_response() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemCommentRow.ic_response)
  if (!_internal_has_ic_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ic_response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ic_response_.IsDefault()) {
    _impl_.ic_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemCommentRow::set_allocated_ic_response(std::string* ic_response) {
  if (ic_response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ic_response_.SetAllocated(ic_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ic_response_.IsDefault()) {
    _impl_.ic_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemCommentRow.ic_response)
}

// -------------------------------------------------------------------

// ItemFeedbackRow

// required uint32 if_id = 1;
inline bool ItemFeedbackRow::_internal_has_if_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_id() const {
  return _internal_has_if_id();
}
inline void ItemFeedbackRow::clear_if_id() {
  _impl_.if_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemFeedbackRow::_internal_if_id() const {
  return _impl_.if_id_;
}
inline uint32_t ItemFeedbackRow::if_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_id)
  return _internal_if_id();
}
inline void ItemFeedbackRow::_internal_set_if_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.if_id_ = value;
}
inline void ItemFeedbackRow::set_if_id(uint32_t value) {
  _internal_set_if_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_id)
}

// required uint32 if_i_id = 2;
inline bool ItemFeedbackRow::_internal_has_if_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_i_id() const {
  return _internal_has_if_i_id();
}
inline void ItemFeedbackRow::clear_if_i_id() {
  _impl_.if_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemFeedbackRow::_internal_if_i_id() const {
  return _impl_.if_i_id_;
}
inline uint32_t ItemFeedbackRow::if_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_i_id)
  return _internal_if_i_id();
}
inline void ItemFeedbackRow::_internal_set_if_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.if_i_id_ = value;
}
inline void ItemFeedbackRow::set_if_i_id(uint32_t value) {
  _internal_set_if_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_i_id)
}

// required uint32 if_u_id = 3;
inline bool ItemFeedbackRow::_internal_has_if_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_u_id() const {
  return _internal_has_if_u_id();
}
inline void ItemFeedbackRow::clear_if_u_id() {
  _impl_.if_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemFeedbackRow::_internal_if_u_id() const {
  return _impl_.if_u_id_;
}
inline uint32_t ItemFeedbackRow::if_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_u_id)
  return _internal_if_u_id();
}
inline void ItemFeedbackRow::_internal_set_if_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.if_u_id_ = value;
}
inline void ItemFeedbackRow::set_if_u_id(uint32_t value) {
  _internal_set_if_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_u_id)
}

// required uint32 if_buyer_id = 4;
inline bool ItemFeedbackRow::_internal_has_if_buyer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_buyer_id() const {
  return _internal_has_if_buyer_id();
}
inline void ItemFeedbackRow::clear_if_buyer_id() {
  _impl_.if_buyer_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ItemFeedbackRow::_internal_if_buyer_id() const {
  return _impl_.if_buyer_id_;
}
inline uint32_t ItemFeedbackRow::if_buyer_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_buyer_id)
  return _internal_if_buyer_id();
}
inline void ItemFeedbackRow::_internal_set_if_buyer_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.if_buyer_id_ = value;
}
inline void ItemFeedbackRow::set_if_buyer_id(uint32_t value) {
  _internal_set_if_buyer_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_buyer_id)
}

// required uint32 if_rating = 5;
inline bool ItemFeedbackRow::_internal_has_if_rating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_rating() const {
  return _internal_has_if_rating();
}
inline void ItemFeedbackRow::clear_if_rating() {
  _impl_.if_rating_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ItemFeedbackRow::_internal_if_rating() const {
  return _impl_.if_rating_;
}
inline uint32_t ItemFeedbackRow::if_rating() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_rating)
  return _internal_if_rating();
}
inline void ItemFeedbackRow::_internal_set_if_rating(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.if_rating_ = value;
}
inline void ItemFeedbackRow::set_if_rating(uint32_t value) {
  _internal_set_if_rating(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_rating)
}

// required uint32 if_date = 6;
inline bool ItemFeedbackRow::_internal_has_if_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_date() const {
  return _internal_has_if_date();
}
inline void ItemFeedbackRow::clear_if_date() {
  _impl_.if_date_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ItemFeedbackRow::_internal_if_date() const {
  return _impl_.if_date_;
}
inline uint32_t ItemFeedbackRow::if_date() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_date)
  return _internal_if_date();
}
inline void ItemFeedbackRow::_internal_set_if_date(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.if_date_ = value;
}
inline void ItemFeedbackRow::set_if_date(uint32_t value) {
  _internal_set_if_date(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_date)
}

// required string if_comment = 7;
inline bool ItemFeedbackRow::_internal_has_if_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemFeedbackRow::has_if_comment() const {
  return _internal_has_if_comment();
}
inline void ItemFeedbackRow::clear_if_comment() {
  _impl_.if_comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemFeedbackRow::if_comment() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemFeedbackRow.if_comment)
  return _internal_if_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemFeedbackRow::set_if_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.if_comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auctionmark.ItemFeedbackRow.if_comment)
}
inline std::string* ItemFeedbackRow::mutable_if_comment() {
  std::string* _s = _internal_mutable_if_comment();
  // @@protoc_insertion_point(field_mutable:auctionmark.ItemFeedbackRow.if_comment)
  return _s;
}
inline const std::string& ItemFeedbackRow::_internal_if_comment() const {
  return _impl_.if_comment_.Get();
}
inline void ItemFeedbackRow::_internal_set_if_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.if_comment_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemFeedbackRow::_internal_mutable_if_comment() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.if_comment_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemFeedbackRow::release_if_comment() {
  // @@protoc_insertion_point(field_release:auctionmark.ItemFeedbackRow.if_comment)
  if (!_internal_has_if_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.if_comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_comment_.IsDefault()) {
    _impl_.if_comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemFeedbackRow::set_allocated_if_comment(std::string* if_comment) {
  if (if_comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.if_comment_.SetAllocated(if_comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_comment_.IsDefault()) {
    _impl_.if_comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auctionmark.ItemFeedbackRow.if_comment)
}

// -------------------------------------------------------------------

// ItemBidRow

// required uint32 ib_id = 1;
inline bool ItemBidRow::_internal_has_ib_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_id() const {
  return _internal_has_ib_id();
}
inline void ItemBidRow::clear_ib_id() {
  _impl_.ib_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ItemBidRow::_internal_ib_id() const {
  return _impl_.ib_id_;
}
inline uint32_t ItemBidRow::ib_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_id)
  return _internal_ib_id();
}
inline void ItemBidRow::_internal_set_ib_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ib_id_ = value;
}
inline void ItemBidRow::set_ib_id(uint32_t value) {
  _internal_set_ib_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_id)
}

// required uint32 ib_i_id = 2;
inline bool ItemBidRow::_internal_has_ib_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_i_id() const {
  return _internal_has_ib_i_id();
}
inline void ItemBidRow::clear_ib_i_id() {
  _impl_.ib_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemBidRow::_internal_ib_i_id() const {
  return _impl_.ib_i_id_;
}
inline uint32_t ItemBidRow::ib_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_i_id)
  return _internal_ib_i_id();
}
inline void ItemBidRow::_internal_set_ib_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ib_i_id_ = value;
}
inline void ItemBidRow::set_ib_i_id(uint32_t value) {
  _internal_set_ib_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_i_id)
}

// required uint32 ib_u_id = 3;
inline bool ItemBidRow::_internal_has_ib_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_u_id() const {
  return _internal_has_ib_u_id();
}
inline void ItemBidRow::clear_ib_u_id() {
  _impl_.ib_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemBidRow::_internal_ib_u_id() const {
  return _impl_.ib_u_id_;
}
inline uint32_t ItemBidRow::ib_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_u_id)
  return _internal_ib_u_id();
}
inline void ItemBidRow::_internal_set_ib_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ib_u_id_ = value;
}
inline void ItemBidRow::set_ib_u_id(uint32_t value) {
  _internal_set_ib_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_u_id)
}

// required uint32 ib_buyer_id = 4;
inline bool ItemBidRow::_internal_has_ib_buyer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_buyer_id() const {
  return _internal_has_ib_buyer_id();
}
inline void ItemBidRow::clear_ib_buyer_id() {
  _impl_.ib_buyer_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemBidRow::_internal_ib_buyer_id() const {
  return _impl_.ib_buyer_id_;
}
inline uint32_t ItemBidRow::ib_buyer_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_buyer_id)
  return _internal_ib_buyer_id();
}
inline void ItemBidRow::_internal_set_ib_buyer_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ib_buyer_id_ = value;
}
inline void ItemBidRow::set_ib_buyer_id(uint32_t value) {
  _internal_set_ib_buyer_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_buyer_id)
}

// required double ib_bid = 5;
inline bool ItemBidRow::_internal_has_ib_bid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_bid() const {
  return _internal_has_ib_bid();
}
inline void ItemBidRow::clear_ib_bid() {
  _impl_.ib_bid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double ItemBidRow::_internal_ib_bid() const {
  return _impl_.ib_bid_;
}
inline double ItemBidRow::ib_bid() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_bid)
  return _internal_ib_bid();
}
inline void ItemBidRow::_internal_set_ib_bid(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ib_bid_ = value;
}
inline void ItemBidRow::set_ib_bid(double value) {
  _internal_set_ib_bid(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_bid)
}

// required double ib_max_bid = 6;
inline bool ItemBidRow::_internal_has_ib_max_bid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_max_bid() const {
  return _internal_has_ib_max_bid();
}
inline void ItemBidRow::clear_ib_max_bid() {
  _impl_.ib_max_bid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double ItemBidRow::_internal_ib_max_bid() const {
  return _impl_.ib_max_bid_;
}
inline double ItemBidRow::ib_max_bid() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_max_bid)
  return _internal_ib_max_bid();
}
inline void ItemBidRow::_internal_set_ib_max_bid(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ib_max_bid_ = value;
}
inline void ItemBidRow::set_ib_max_bid(double value) {
  _internal_set_ib_max_bid(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_max_bid)
}

// required uint32 ib_created = 7;
inline bool ItemBidRow::_internal_has_ib_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_created() const {
  return _internal_has_ib_created();
}
inline void ItemBidRow::clear_ib_created() {
  _impl_.ib_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ItemBidRow::_internal_ib_created() const {
  return _impl_.ib_created_;
}
inline uint32_t ItemBidRow::ib_created() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_created)
  return _internal_ib_created();
}
inline void ItemBidRow::_internal_set_ib_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ib_created_ = value;
}
inline void ItemBidRow::set_ib_created(uint32_t value) {
  _internal_set_ib_created(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_created)
}

// required uint32 ib_updated = 8;
inline bool ItemBidRow::_internal_has_ib_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ItemBidRow::has_ib_updated() const {
  return _internal_has_ib_updated();
}
inline void ItemBidRow::clear_ib_updated() {
  _impl_.ib_updated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ItemBidRow::_internal_ib_updated() const {
  return _impl_.ib_updated_;
}
inline uint32_t ItemBidRow::ib_updated() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemBidRow.ib_updated)
  return _internal_ib_updated();
}
inline void ItemBidRow::_internal_set_ib_updated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ib_updated_ = value;
}
inline void ItemBidRow::set_ib_updated(uint32_t value) {
  _internal_set_ib_updated(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemBidRow.ib_updated)
}

// -------------------------------------------------------------------

// ItemMaxBidRow

// required uint32 imb_i_id = 1;
inline bool ItemMaxBidRow::_internal_has_imb_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_i_id() const {
  return _internal_has_imb_i_id();
}
inline void ItemMaxBidRow::clear_imb_i_id() {
  _impl_.imb_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_i_id() const {
  return _impl_.imb_i_id_;
}
inline uint32_t ItemMaxBidRow::imb_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_i_id)
  return _internal_imb_i_id();
}
inline void ItemMaxBidRow::_internal_set_imb_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.imb_i_id_ = value;
}
inline void ItemMaxBidRow::set_imb_i_id(uint32_t value) {
  _internal_set_imb_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_i_id)
}

// required uint32 imb_u_id = 2;
inline bool ItemMaxBidRow::_internal_has_imb_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_u_id() const {
  return _internal_has_imb_u_id();
}
inline void ItemMaxBidRow::clear_imb_u_id() {
  _impl_.imb_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_u_id() const {
  return _impl_.imb_u_id_;
}
inline uint32_t ItemMaxBidRow::imb_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_u_id)
  return _internal_imb_u_id();
}
inline void ItemMaxBidRow::_internal_set_imb_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.imb_u_id_ = value;
}
inline void ItemMaxBidRow::set_imb_u_id(uint32_t value) {
  _internal_set_imb_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_u_id)
}

// required uint32 imb_ib_id = 3;
inline bool ItemMaxBidRow::_internal_has_imb_ib_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_ib_id() const {
  return _internal_has_imb_ib_id();
}
inline void ItemMaxBidRow::clear_imb_ib_id() {
  _impl_.imb_ib_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_ib_id() const {
  return _impl_.imb_ib_id_;
}
inline uint32_t ItemMaxBidRow::imb_ib_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_ib_id)
  return _internal_imb_ib_id();
}
inline void ItemMaxBidRow::_internal_set_imb_ib_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.imb_ib_id_ = value;
}
inline void ItemMaxBidRow::set_imb_ib_id(uint32_t value) {
  _internal_set_imb_ib_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_ib_id)
}

// required uint32 imb_ib_i_id = 4;
inline bool ItemMaxBidRow::_internal_has_imb_ib_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_ib_i_id() const {
  return _internal_has_imb_ib_i_id();
}
inline void ItemMaxBidRow::clear_imb_ib_i_id() {
  _impl_.imb_ib_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_ib_i_id() const {
  return _impl_.imb_ib_i_id_;
}
inline uint32_t ItemMaxBidRow::imb_ib_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_ib_i_id)
  return _internal_imb_ib_i_id();
}
inline void ItemMaxBidRow::_internal_set_imb_ib_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.imb_ib_i_id_ = value;
}
inline void ItemMaxBidRow::set_imb_ib_i_id(uint32_t value) {
  _internal_set_imb_ib_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_ib_i_id)
}

// required uint32 imb_ib_u_id = 5;
inline bool ItemMaxBidRow::_internal_has_imb_ib_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_ib_u_id() const {
  return _internal_has_imb_ib_u_id();
}
inline void ItemMaxBidRow::clear_imb_ib_u_id() {
  _impl_.imb_ib_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_ib_u_id() const {
  return _impl_.imb_ib_u_id_;
}
inline uint32_t ItemMaxBidRow::imb_ib_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_ib_u_id)
  return _internal_imb_ib_u_id();
}
inline void ItemMaxBidRow::_internal_set_imb_ib_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.imb_ib_u_id_ = value;
}
inline void ItemMaxBidRow::set_imb_ib_u_id(uint32_t value) {
  _internal_set_imb_ib_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_ib_u_id)
}

// required uint32 imb_created = 6;
inline bool ItemMaxBidRow::_internal_has_imb_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_created() const {
  return _internal_has_imb_created();
}
inline void ItemMaxBidRow::clear_imb_created() {
  _impl_.imb_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_created() const {
  return _impl_.imb_created_;
}
inline uint32_t ItemMaxBidRow::imb_created() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_created)
  return _internal_imb_created();
}
inline void ItemMaxBidRow::_internal_set_imb_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.imb_created_ = value;
}
inline void ItemMaxBidRow::set_imb_created(uint32_t value) {
  _internal_set_imb_created(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_created)
}

// required uint32 imb_updated = 7;
inline bool ItemMaxBidRow::_internal_has_imb_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ItemMaxBidRow::has_imb_updated() const {
  return _internal_has_imb_updated();
}
inline void ItemMaxBidRow::clear_imb_updated() {
  _impl_.imb_updated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ItemMaxBidRow::_internal_imb_updated() const {
  return _impl_.imb_updated_;
}
inline uint32_t ItemMaxBidRow::imb_updated() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemMaxBidRow.imb_updated)
  return _internal_imb_updated();
}
inline void ItemMaxBidRow::_internal_set_imb_updated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.imb_updated_ = value;
}
inline void ItemMaxBidRow::set_imb_updated(uint32_t value) {
  _internal_set_imb_updated(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemMaxBidRow.imb_updated)
}

// -------------------------------------------------------------------

// ItemPurchaseRow

// required uint32 ip_id = 1;
inline bool ItemPurchaseRow::_internal_has_ip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemPurchaseRow::has_ip_id() const {
  return _internal_has_ip_id();
}
inline void ItemPurchaseRow::clear_ip_id() {
  _impl_.ip_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ItemPurchaseRow::_internal_ip_id() const {
  return _impl_.ip_id_;
}
inline uint32_t ItemPurchaseRow::ip_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemPurchaseRow.ip_id)
  return _internal_ip_id();
}
inline void ItemPurchaseRow::_internal_set_ip_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_id_ = value;
}
inline void ItemPurchaseRow::set_ip_id(uint32_t value) {
  _internal_set_ip_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemPurchaseRow.ip_id)
}

// required uint32 ip_ib_id = 2;
inline bool ItemPurchaseRow::_internal_has_ip_ib_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ItemPurchaseRow::has_ip_ib_id() const {
  return _internal_has_ip_ib_id();
}
inline void ItemPurchaseRow::clear_ip_ib_id() {
  _impl_.ip_ib_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ItemPurchaseRow::_internal_ip_ib_id() const {
  return _impl_.ip_ib_id_;
}
inline uint32_t ItemPurchaseRow::ip_ib_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemPurchaseRow.ip_ib_id)
  return _internal_ip_ib_id();
}
inline void ItemPurchaseRow::_internal_set_ip_ib_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_ib_id_ = value;
}
inline void ItemPurchaseRow::set_ip_ib_id(uint32_t value) {
  _internal_set_ip_ib_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemPurchaseRow.ip_ib_id)
}

// required uint32 ip_i_id = 3;
inline bool ItemPurchaseRow::_internal_has_ip_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ItemPurchaseRow::has_ip_i_id() const {
  return _internal_has_ip_i_id();
}
inline void ItemPurchaseRow::clear_ip_i_id() {
  _impl_.ip_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ItemPurchaseRow::_internal_ip_i_id() const {
  return _impl_.ip_i_id_;
}
inline uint32_t ItemPurchaseRow::ip_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemPurchaseRow.ip_i_id)
  return _internal_ip_i_id();
}
inline void ItemPurchaseRow::_internal_set_ip_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ip_i_id_ = value;
}
inline void ItemPurchaseRow::set_ip_i_id(uint32_t value) {
  _internal_set_ip_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemPurchaseRow.ip_i_id)
}

// required uint32 ip_u_id = 4;
inline bool ItemPurchaseRow::_internal_has_ip_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ItemPurchaseRow::has_ip_u_id() const {
  return _internal_has_ip_u_id();
}
inline void ItemPurchaseRow::clear_ip_u_id() {
  _impl_.ip_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ItemPurchaseRow::_internal_ip_u_id() const {
  return _impl_.ip_u_id_;
}
inline uint32_t ItemPurchaseRow::ip_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemPurchaseRow.ip_u_id)
  return _internal_ip_u_id();
}
inline void ItemPurchaseRow::_internal_set_ip_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ip_u_id_ = value;
}
inline void ItemPurchaseRow::set_ip_u_id(uint32_t value) {
  _internal_set_ip_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemPurchaseRow.ip_u_id)
}

// required uint32 ip_date = 5;
inline bool ItemPurchaseRow::_internal_has_ip_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ItemPurchaseRow::has_ip_date() const {
  return _internal_has_ip_date();
}
inline void ItemPurchaseRow::clear_ip_date() {
  _impl_.ip_date_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ItemPurchaseRow::_internal_ip_date() const {
  return _impl_.ip_date_;
}
inline uint32_t ItemPurchaseRow::ip_date() const {
  // @@protoc_insertion_point(field_get:auctionmark.ItemPurchaseRow.ip_date)
  return _internal_ip_date();
}
inline void ItemPurchaseRow::_internal_set_ip_date(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ip_date_ = value;
}
inline void ItemPurchaseRow::set_ip_date(uint32_t value) {
  _internal_set_ip_date(value);
  // @@protoc_insertion_point(field_set:auctionmark.ItemPurchaseRow.ip_date)
}

// -------------------------------------------------------------------

// UserItemRow

// required uint32 ui_u_id = 1;
inline bool UserItemRow::_internal_has_ui_u_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserItemRow::has_ui_u_id() const {
  return _internal_has_ui_u_id();
}
inline void UserItemRow::clear_ui_u_id() {
  _impl_.ui_u_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UserItemRow::_internal_ui_u_id() const {
  return _impl_.ui_u_id_;
}
inline uint32_t UserItemRow::ui_u_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserItemRow.ui_u_id)
  return _internal_ui_u_id();
}
inline void UserItemRow::_internal_set_ui_u_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ui_u_id_ = value;
}
inline void UserItemRow::set_ui_u_id(uint32_t value) {
  _internal_set_ui_u_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserItemRow.ui_u_id)
}

// required uint32 ui_i_id = 2;
inline bool UserItemRow::_internal_has_ui_i_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserItemRow::has_ui_i_id() const {
  return _internal_has_ui_i_id();
}
inline void UserItemRow::clear_ui_i_id() {
  _impl_.ui_i_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserItemRow::_internal_ui_i_id() const {
  return _impl_.ui_i_id_;
}
inline uint32_t UserItemRow::ui_i_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserItemRow.ui_i_id)
  return _internal_ui_i_id();
}
inline void UserItemRow::_internal_set_ui_i_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ui_i_id_ = value;
}
inline void UserItemRow::set_ui_i_id(uint32_t value) {
  _internal_set_ui_i_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserItemRow.ui_i_id)
}

// required uint32 ui_seller_id = 3;
inline bool UserItemRow::_internal_has_ui_seller_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserItemRow::has_ui_seller_id() const {
  return _internal_has_ui_seller_id();
}
inline void UserItemRow::clear_ui_seller_id() {
  _impl_.ui_seller_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserItemRow::_internal_ui_seller_id() const {
  return _impl_.ui_seller_id_;
}
inline uint32_t UserItemRow::ui_seller_id() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserItemRow.ui_seller_id)
  return _internal_ui_seller_id();
}
inline void UserItemRow::_internal_set_ui_seller_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ui_seller_id_ = value;
}
inline void UserItemRow::set_ui_seller_id(uint32_t value) {
  _internal_set_ui_seller_id(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserItemRow.ui_seller_id)
}

// required uint32 ui_created = 4;
inline bool UserItemRow::_internal_has_ui_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserItemRow::has_ui_created() const {
  return _internal_has_ui_created();
}
inline void UserItemRow::clear_ui_created() {
  _impl_.ui_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserItemRow::_internal_ui_created() const {
  return _impl_.ui_created_;
}
inline uint32_t UserItemRow::ui_created() const {
  // @@protoc_insertion_point(field_get:auctionmark.UserItemRow.ui_created)
  return _internal_ui_created();
}
inline void UserItemRow::_internal_set_ui_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ui_created_ = value;
}
inline void UserItemRow::set_ui_created(uint32_t value) {
  _internal_set_ui_created(value);
  // @@protoc_insertion_point(field_set:auctionmark.UserItemRow.ui_created)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace auctionmark

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::auctionmark::Tables> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::auctionmark::Tables>() {
  return ::auctionmark::Tables_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_auctionmark_2eproto
